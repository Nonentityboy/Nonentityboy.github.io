<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Another Curtin</title>
  
  
  <link href="https://nonentityboy.github.io/atom.xml" rel="self"/>
  
  <link href="https://nonentityboy.github.io/"/>
  <updated>2023-03-17T15:40:05.570Z</updated>
  <id>https://nonentityboy.github.io/</id>
  
  <author>
    <name>Curtin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大学毕业一年后收获与感悟</title>
    <link href="https://nonentityboy.github.io/2022/07/01/%E5%A4%A7%E5%AD%A6%E6%AF%95%E4%B8%9A%E4%B8%80%E5%B9%B4%E5%90%8E%E6%94%B6%E8%8E%B7%E4%B8%8E%E6%84%9F%E6%82%9F/"/>
    <id>https://nonentityboy.github.io/2022/07/01/%E5%A4%A7%E5%AD%A6%E6%AF%95%E4%B8%9A%E4%B8%80%E5%B9%B4%E5%90%8E%E6%94%B6%E8%8E%B7%E4%B8%8E%E6%84%9F%E6%82%9F/</id>
    <published>2022-07-01T15:34:19.000Z</published>
    <updated>2023-03-17T15:40:05.570Z</updated>
    
    <content type="html"><![CDATA[<p>时间转眼飞逝一年。回头思索，好像经历了很多，但又好像两眼一黑，时光凭空消失一般，自己已经过完职场生涯的第一年。</p><a id="more"></a><p>我在“传统人生”的“主旋律”上却有了些许前进（恋爱、购房、升职），可以说生活有了非常大的变化，个人感受上也十分美满。然而在潜意识中，却冥冥觉得实感有那么一点不够。</p><p>换个角度而言，明明过得挺好，精神感官上却觉得不充实，这种割裂感很微妙，难以具象言表。笼统说来，主要是目前的现实，都是循序渐进达成的，讲究一个水到渠成，并不会产生天上地下的跃进。因此在生活上，便不会出现跳跃感，尽管取得了不少“主旋律”成就，但似乎一切都是理所应当。</p><p>另一方面，尽管我本身是不好动的人，但疫情的出现确实加剧了“同质化日子”的频次。居家办公、常戴口罩、出行受限，这些都是疫情带来的变化。然而比起这些变化，更大的感观却是疫情之下的时间变得更易流逝了，更为规律化、平淡化的日常使得时光缺乏记忆点，稍纵即逝。</p><p>造成时光飞逝而却不自知的另一个原因，我归根于个人爱好的没落。长期来看，这是一种个人目标，在未来五年、十年甚至更久，想达成一个怎样的目标。短期来看，是个人兴趣爱好，业余能有属于自己的兴趣活动，能够充实自我，或者帮助达成长期目标。</p><p>尽管上大学时有些杂乱的小爱好，例如penbeat、养花草、骑行，但大都只是些仅有时下热度的、不可持续的折腾活，并不是我内心想要达到的爱好领域。并且随着开始工作，这种所谓的爱好正在消失殆尽。初高中期间深度参与观看的动漫，几乎没有再追，自己的网站项目也没有再经营，消失于江湖。</p><p>这主要还是归结于工作对个人精力的消耗。在互联网工作节奏之下，个人生活时间被极大压缩，下班之后也难以有精力再去经营所谓的个人兴趣爱好。一个很直观的变化是，工作使得我下班后不想再碰电脑。移动互联网的飞速发展也使得手机上可获得更多娱乐信息，逐渐在购物、社交、短视频等茧房中刷刷刷得停不下来。另一方面，职场内卷等“主旋律”也进一步挤压了时间。</p><p>最近，互联网行业波涛汹涌。自己身边的朋友或多或少受到影响。<br>同时我的职业生涯也发生巨大变化，工作内容从传统互联网to B广告投放，到to G政府相关项目，跨界之大，很是神奇。也无异于摸着石头过河，冷暖自知。</p><p>前两年间，我在所在的前团队业务起起伏伏，有声势浩大的风风光光，也有偃旗息鼓的迷途探索。然而比起业务的时运变幻，作为小兵只需拧好手上的螺丝钉，无需太多的深入思考。 即便是面临角色的变更，也有其他人“顶着”。</p><p>换团队后，开始面临熟悉而又充满挑战的工作。熟悉在于，相关的技术栈在我了解范畴之中。挑战在于，技术基础建设从零开始；工作相关角色的变更从零开始；新团队不同于互联网的工作方式从零开始。 团队大多数成员均是一年以内聚集而来，工作内容是研发地图引擎管理工具，诚然，这有些脱离我的掌控。</p><p>由于互联网行业近期动荡加剧，我也同样也在问自己这样一个问题？<br>“我有多少能力是和平台无关的，我还有哪些谋生的手段？”<br>思考这个问题的起因是从 21年末对职业生涯的迷茫，今年的裁员潮让我有了更深的体会。</p><p>我发现外在的东西很脆弱，互联网公司的团队和组织架构变化非常快，一年可能会经历很多次调整。比如换了个团队，换了个老板，换了个业务，这些变化都可能让之前以为的“能力”突然消失，因此我开始更关注自己的内在价值。</p><p>长坡厚雪的积累，需要在一个有价值的领域相对长期的钻研。用大量时间积累的经验和对细节的持续观察，更容易产生有价值的洞见。</p><p>现在我对这个问题的答案还是很模糊，还需要更多时间来寻找答案…</p><p><img src="https://raw.githubusercontent.com/Nonentityboy/PicGoToGitHub/study_note_blog/Snipaste_2023-03-17_23-39-35.png" alt></p><p>———————————————</p><p>期望自己能够保持健康、笃定、自洽，个人生涯依旧落实长期思维和健康发展。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;时间转眼飞逝一年。回头思索，好像经历了很多，但又好像两眼一黑，时光凭空消失一般，自己已经过完职场生涯的第一年。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>小程序底层原理刨析</title>
    <link href="https://nonentityboy.github.io/2020/06/21/miniprogram-learn/"/>
    <id>https://nonentityboy.github.io/2020/06/21/miniprogram-learn/</id>
    <published>2020-06-20T17:05:44.000Z</published>
    <updated>2020-06-20T17:08:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>小程序的底层架构，从小程序的由来、到双线程的出现、设计、通信、到基础库、Exparser 框架、再到运行机制、性能优化等等，都是一个个相关而又相互影响的选择。从前端技术选型方案角度考虑，探寻小程序底层机制。</p><span id="more"></span><h2 id="01：小程序底层原理"><a href="#01：小程序底层原理" class="headerlink" title="01：小程序底层原理"></a>01：小程序底层原理</h2><h3 id="1-从前端技术选型方案角度考虑，探寻小程序底层机制"><a href="#1-从前端技术选型方案角度考虑，探寻小程序底层机制" class="headerlink" title="1. 从前端技术选型方案角度考虑，探寻小程序底层机制"></a>1. 从前端技术选型方案角度考虑，探寻小程序底层机制</h3><ul><li>用纯客户端原生技术来渲染</li><li>用纯 Web 技术来渲染</li><li>用客户端原生技术与 Web 技术结合的混合技术（简称 Hybrid 技术）来渲染（小程序用这种）<ul><li>扩展 Web 能力，比如像输出框组件（input，textarea）更好控制键盘能力</li><li>体验更好，减轻WebView的渲染工作</li><li>用客户端原生渲染一些复杂组件，提供更好的性能</li></ul></li></ul><blockquote><p>开发者若是直接通过JS操作DOM,那么一些敏感数据就毫无安全可言，微信提供沙箱环境来运行开发者的JS代码，这个环境不能有任何浏览器相关的接口，只能通过 JS 解释执行环境，类似于 HTML5 的 ServiceWorker 启动另一个线程来执行 JS 。</p></blockquote><blockquote><p>这样设计的原因是为了解决管控安全问题，需要阻止开发者试用浏览器window对象，跳转页面，操作DOM，动态执行脚本的开放性接口。</p></blockquote><h3 id="2-双线程模型与双线程通信具体流程"><a href="#2-双线程模型与双线程通信具体流程" class="headerlink" title="2. 双线程模型与双线程通信具体流程"></a>2. 双线程模型与双线程通信具体流程</h3><p><img src="https://s1.ax1x.com/2020/05/16/YcL7Is.png" alt="image"></p><p>这样设计的原因是为了解决管控安全问题，需要阻止开发者试用浏览器window对象，跳转页面，操作DOM，动态执行脚本的开放性接口。</p><p><img src="https://segmentfault.com/img/bVbsq6i?w=2168&amp;h=460" alt><br>可以使用客户端系统的 JavaScript 引擎，iOS 下的 JavaScriptCore 框架， 安卓下腾讯 x5 内核提供的 JScore 环境。</p><p>这个沙箱环境提供纯 JavaScript 解释执行环境，没有任何浏览器相关接口。</p><p>这就是小程序双线程模型的由来：</p><ul><li>逻辑层：创建一个单独的线程去执行 JavaScript ，在这里执行的都是小程序业务逻辑的代码，负责逻辑处理、数据请求、接口调用等</li><li>视图层：界面渲染相关的任务全都在 WebView 线程里执行，通过逻辑层代码去控制渲染哪些界面。一个小程序存在多个界面，所以视图层存在多个 WebView 线程</li><li>JSBridge 起到架起上层开发与 Native (系统层）的桥梁，使得小程序可通过 API 使用原生功能，且部分组件为原生组件实现，从而有良好体验</li></ul><p><img src="https://s1.ax1x.com/2020/05/16/YcXdBD.png" alt="image"></p><ul><li>在渲染层把 WXML 转化成对应的 JS 对象。</li><li>在逻辑层发生数据变更的时候，通过宿主环境提供的 setData 方法把数据从逻辑层传递到 Native，再转发到渲染层。</li><li>经过对比前后差异，把差异应用在原来的 DOM 树上，更新界面。我们通过把 WXML 转化为数据，通过 Native 进行转发，来实现逻辑层和渲染层的交互和通信。而这样一个完整的框架，离不开<code>小程序的基础库</code>。</li></ul><h3 id="3-逻辑层和渲染层的交互和通信离不开小程序的基础库Exparser"><a href="#3-逻辑层和渲染层的交互和通信离不开小程序的基础库Exparser" class="headerlink" title="3. 逻辑层和渲染层的交互和通信离不开小程序的基础库Exparser"></a>3. 逻辑层和渲染层的交互和通信离不开小程序的基础库Exparser</h3><p>小程序基础库可以被注入到视图层和逻辑层运行，用于一下几个方面：</p><ul><li>视图层，提供各类组件来组建界面元素</li><li>逻辑层，提供各类 API 来处理各种逻辑</li><li>处理数据绑定、组件系统、事件系统、通信系统等一系列框架逻辑</li></ul><blockquote><p>小程序渲染层和逻辑层是两个线程管理，两个线程各自注入了基础库</p></blockquote><p>小程序的基础库不会被打包在某个小程序的代码包里，会提前内置到微信客户端里，这样可以：</p><ul><li>降低业务小程序的代码包大小</li><li>可以单独修复基础库中的 Bug, 无需修改到业务小程序的代码包</li></ul><h4 id="Expareser框架"><a href="#Expareser框架" class="headerlink" title="Expareser框架"></a>Expareser框架</h4><blockquote><p>Exparser是微信小程序的组件组织框架，内置在小程序基础库中，为小程序的各种组件提供基础的支持。小程序内的所有组件，包括内置组件和自定义组件，都由Exparser组织管理。</p></blockquote><p>Exparser的主要特点包括以下几点：</p><ul><li>基于Shadow DOM模型：模型上与WebComponents的ShadowDOM高度相似，但不依赖浏览器的原生支持，也没有其他依赖库；实现时，还针对性地增加了其他API以支持小程序组件编程。</li><li>可在纯JS环境中运行：这意味着逻辑层也具有一定的组件树组织能力。<br>高效轻量：性能表现好，在组件实例极多的环境下表现尤其优异，同时代码尺寸也较小。</li><li>小程序中，所有节点树相关的操作都依赖于Exparser，包括WXML到页面最终节点树的构建、createSelectorQuery调用和自定义组件特性等。<br>内置组件</li></ul><blockquote><p>基于Exparser框架，小程序内置了一套组件，提供了视图容器类、表单类、导航类、媒体类、开放类等几十种组件。有了这么丰富的组件，再配合WXSS，可以搭建出任何效果的界面。在功能层面上，也满足绝大部分需求。</p></blockquote><h3 id="4-小程序运行机制"><a href="#4-小程序运行机制" class="headerlink" title="4. 小程序运行机制"></a>4. 小程序运行机制</h3><blockquote><p><b>小程序启动会有两种情况，一种是「冷启动」，一种是「热启动」。</b>假如用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台状态的小程序切换到前台，这个过程就是热启动；冷启动指的是用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动。</p></blockquote><h4 id="小程序没有重启的概念"><a href="#小程序没有重启的概念" class="headerlink" title="小程序没有重启的概念"></a>小程序没有重启的概念</h4><p>当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后（目前是5分钟）会被微信主动销毁<br>当短时间内（5s）连续收到两次以上收到系统内存告警，会进行小程序的销毁。</p><p><img src="https://segmentfault.com/img/bVbsq3u?w=826&amp;h=429" alt></p><h3 id="5-什么是JSBridge"><a href="#5-什么是JSBridge" class="headerlink" title="5. 什么是JSBridge"></a>5. 什么是JSBridge</h3><blockquote><p>JavaScript 是运行在一个单独的 JS Context 中（例如，WebView 的 Webkit 引擎、JSCore）。由于这些 Context 与原生运行环境的天然隔离，我们可以将这种情况与 RPC（Remote Procedure Call，远程过程调用）通信进行类比，将 Native 与 JavaScript 的每次互相调用看做一次 RPC 调用。</p></blockquote><p>在 JSBridge 的设计中，可以把前端看做 RPC 的客户端，把 Native 端看做 RPC 的服务器端，从而 JSBridge 要实现的主要逻辑就出现了：通信调用（Native 与 JS 通信） 和句柄解析调用。</p><p><code>作用</code>：主要是给JavaScript提供调用 Native 功能的接口，让混合开发中的前端部分可以方便的使用 Native 功能(例：地址位置、蓝牙、摄像头)</p><p>而且 JSBridge 的功能不止调用 Native 功能这么简单，实际上，JSBridge 就像其名称中的 Bridge 的意义一样，是 Native 和非 Native 之间的桥梁，它的核心是构建 Native 和非 Native 间消息通信的信道，且这个<code>信道是双向</code>的。</p><p>双向通信的信道：</p><ul><li>JS 向 Native 发送消息：调用相关功能，通知 Native 当前 JS 的相关状态等</li><li>Native 向 JS 发送消息：回溯调用结果、消息推送，通知 JS 当前 Native 的状态</li></ul><h3 id="6-开发中性能优化"><a href="#6-开发中性能优化" class="headerlink" title="6. 开发中性能优化"></a>6. 开发中性能优化</h3><p>主要的优化策略可以归纳为三点：</p><ul><li>精简代码，降低WXML结构和JS代码的复杂性；</li><li>合理使用setData调用，减少setData次数和数据量；</li><li>必要时使用分包优化。</li></ul><h4 id="1、setData-工作原理"><a href="#1、setData-工作原理" class="headerlink" title="1、setData 工作原理"></a>1、setData 工作原理</h4><p>小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。当前，视图层和逻辑层的数据传输，实际上通过两边提供的 evaluateJavascript 所实现。即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。</p><p>而 evaluateJavascript 的执行会受很多方面的影响，数据到达视图层并不是实时的。</p><h4 id="2、常见的-setData-操作错误"><a href="#2、常见的-setData-操作错误" class="headerlink" title="2、常见的 setData 操作错误"></a>2、常见的 setData 操作错误</h4><p>频繁的去 setData在我们分析过的一些案例里，部分小程序会非常频繁（毫秒级）的去setData，其导致了两个后果：Android下用户在滑动时会感觉到卡顿，操作反馈延迟严重，因为 JS 线程一直在编译执行渲染，未能及时将用户操作事件传递到逻辑层，逻辑层亦无法及时将操作处理结果及时传递到视图层；渲染有出现延时，由于 WebView 的 JS 线程一直处于忙碌状态，逻辑层到页面层的通信耗时上升，视图层收到的数据消息时距离发出时间已经过去了几百毫秒，渲染的结果并不实时；<br>每次 setData 都传递大量新数据由setData的底层实现可知，我们的数据传输实际是一次 evaluateJavascript<br>脚本过程，当数据量过大时会增加脚本的编译执行时间，占用 WebView JS 线程， 后台态页面进行<br>setData当页面进入后台态（用户不可见），不应该继续去进行setData，后台态页面的渲染用户是无法感受的，另外后台态页面去setData也会抢占前台页面的执行。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>分析了小程序的底层架构，从小程序的由来、到双线程的出现、设计、通信、到基础库、Exparser 框架、再到运行机制、性能优化等等，都是一个个相关而又相互影响的选择。关于小程序的底层框架设计，其实涉及到的还有很多，比如自定义组件，原生组件、性能优化等方面，都不是一点能讲完的，还要多看源码，多思考。每一个框架的诞生都有其意义，我们作为开发者能做的不只是会使用这个工具，还应理解它的设计模式。只有这样才不会被工具左右，才能走的更远！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;小程序的底层架构，从小程序的由来、到双线程的出现、设计、通信、到基础库、Exparser 框架、再到运行机制、性能优化等等，都是一个个相关而又相互影响的选择。从前端技术选型方案角度考虑，探寻小程序底层机制。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Chrome_DevTools使用</title>
    <link href="https://nonentityboy.github.io/2020/02/07/Chrome-DevTools-Tips/"/>
    <id>https://nonentityboy.github.io/2020/02/07/Chrome-DevTools-Tips/</id>
    <published>2020-02-07T05:00:27.000Z</published>
    <updated>2020-02-07T05:25:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>能很好地使⽤ DevTools 的话，它能够很好地帮助你提⾼⽣产⼒和解决问题的能⼒。</p><span id="more"></span><h1 id="Elements"><a href="#Elements" class="headerlink" title="Elements"></a>Elements</h1><p><img src="/2020/02/07/Chrome-DevTools-Tips/elements.jpg" alt="elements"></p><p>这个功能肯定是⼤家经常⽤到的，我们可以通过它来可视化所有的DOM 标签，可以查看任何 DOM 的属性，接下来我们就来学习⼀下关于这⽅⾯的 Tips。</p><h2 id="Element-状态"><a href="#Element-状态" class="headerlink" title="Element 状态"></a>Element 状态</h2><p>你可能会在开发中遇到这么⼀个场景：给⼀个 a 标签设置了多种状态下的样式，但是如果⼿动去改变状态的话就有点麻烦，这时候这个 Tips 就能帮你解决这个问题。<br><img src="/2020/02/07/Chrome-DevTools-Tips/elements_state.jpg" alt="elements_state"></p><h2 id="快速定位-Element"><a href="#快速定位-Element" class="headerlink" title="快速定位 Element"></a>快速定位 Element</h2><p>通常⻚⾯都是可以滚动的，那么如果想查看的元素不在当前窗⼝的<br>话，你还需要滚动⻚⾯才能找到元素，这时候这个 Tips 就能帮你解<br>决这个问题。<br><img src="/2020/02/07/Chrome-DevTools-Tips/quick_element.jpg" alt="quick_elements"></p><p>当点击这个选项的时候，⻚⾯就会⾃动滚动到元素所在的位置，这样<br>⽐边滚动边查看是否找到元素的⽅式⽅便多了。</p><h1 id="DOM-断点"><a href="#DOM-断点" class="headerlink" title="DOM 断点"></a>DOM 断点</h1><p>给 JS 打断点想必各位都听过，但是 DOM 断点知道的⼈应该就少了。如果你想查看⼀个 DOM 元素是如何通过 JS 更改的，你就可以使⽤这个功能。<br>当我们给 ul 添加该断点以后，⼀旦 ul ⼦元素发⽣了改动，⽐如说增加了⼦元素的个数，那么就会⾃动跳转到对应的 JS 代码.</p><p><img src="/2020/02/07/Chrome-DevTools-Tips/Dom_debugger.jpg" alt="Dom_debbger"></p><h1 id="查看事件"><a href="#查看事件" class="headerlink" title="查看事件"></a>查看事件</h1><p>我们还可以通过 DevTools 来查看⻚⾯中添加了多少的事件。假如当你发现⻚⾯滚动起来有性能上的问题时，就可以查看⼀下有多少scroll 事件被添加了.</p><p><img src="/2020/02/07/Chrome-DevTools-Tips/scroll_window.jpg" alt="scroll_window"></p><h1 id="找到之前查看过的-DOM-元素"><a href="#找到之前查看过的-DOM-元素" class="headerlink" title="找到之前查看过的 DOM 元素"></a>找到之前查看过的 DOM 元素</h1><p>不知道你是否遇到过这样的问题，找不到之前查看过的 DOM 元素在<br>哪⾥了，需要⼀个个去找这就有点麻烦了，这时候你就可以使⽤这个<br>功能。</p><p><img src="/2020/02/07/Chrome-DevTools-Tips/find_dom.jpg" alt="find_dom"></p><p>我们可以通过 $0 来找到上⼀次查看过的 DOM 元素，$1 就是上上次的元素，之后以此类推。这时候你可能会说，打印出来元素有啥⽤，在具体什么位置还要去找啊，不⽤急，⻢上我就可以解决这个问题</p><p><img src="/2020/02/07/Chrome-DevTools-Tips/reveal_dom.jpg" alt="relvea"></p><p>当你点击这个选项时，⻚⾯⽴⻢会跳转⾄元素所在位置，并且 DevTools 也会变到 Elements 标签.</p><h1 id="Debugging"><a href="#Debugging" class="headerlink" title="Debugging"></a>Debugging</h1><p>给 JS 打断点想必⼤家都会，但是打断点也是有⼀个不为⼈知的 Tips<br>的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">10</span>; index++) &#123;</span><br><span class="line">    <span class="comment">// 各种逻辑</span></span><br><span class="line">    <span class="built_in">console</span>.log(index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对于这段代码来说，如果我只想看到 index 为 5 时相应的断点信息，但是⼀旦打了断点，就会每次循环都会停下来，很浪费时间，那么通过这个⼩技巧我们就可以圆满解决这个问题<br><img src="/2020/02/07/Chrome-DevTools-Tips/Snipaste_2020-02-07_13-21-46.jpg" alt="111"></p><p>⾸先我们先右键断点，然后选择 Edit breakpoint… 选项<br><img src="/2020/02/07/Chrome-DevTools-Tips/Snipaste_2020-02-07_13-22-43.jpg" alt="111"></p><p>在弹框内输⼊ index === 5，这样断点就会变为橙⾊，并且只有当<br>符合表达式的情况时断点才会被执⾏</p><p><img src="/2020/02/07/Chrome-DevTools-Tips/Snipaste_2020-02-07_13-22-53.jpg" alt="1111"></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>虽然这篇文章的内容并不多，但是涉及到的⼏个场景都是⽇常经常会碰<br>到的。虽然日常开发我一直 console.log 比较多。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;能很好地使⽤ DevTools 的话，它能够很好地帮助你提⾼⽣产⼒和解决问题的能⼒。&lt;/p&gt;</summary>
    
    
    
    
    <category term="生产工具" scheme="https://nonentityboy.github.io/tags/%E7%94%9F%E4%BA%A7%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>插入排序比冒泡排序更受欢迎？</title>
    <link href="https://nonentityboy.github.io/2020/02/06/sort-num/"/>
    <id>https://nonentityboy.github.io/2020/02/06/sort-num/</id>
    <published>2020-02-06T04:14:09.000Z</published>
    <updated>2020-02-06T12:33:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>排序算法太多了，打开Google，搜索<code>排序</code>二字，出现了好多名字都没听过的，比如猴子排序、睡眠排序、面条排序。<br>今天也就复习一下常用的排序：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。</p><span id="more"></span><h1 id="按照时间复杂度"><a href="#按照时间复杂度" class="headerlink" title="按照时间复杂度"></a>按照时间复杂度</h1><table><thead><tr><th>排序算法</th><th>时间复杂度</th><th>是否基于比较</th></tr></thead><tbody><tr><td>冒泡、插入、选择</td><td>O(n²)</td><td>是</td></tr><tr><td>快排、归并</td><td>O(nlogn)</td><td>是</td></tr><tr><td>桶、计数、基数</td><td>O(n)</td><td>否</td></tr></tbody></table><blockquote><p>先抛出一个问题，插入排序与冒泡排序时间复杂度相同，都为O(n²)，为什么实际开发里，更倾向于用插入排序而不是冒泡排序</p></blockquote><h1 id="分析一个“排序算法”"><a href="#分析一个“排序算法”" class="headerlink" title="分析一个“排序算法”"></a>分析一个“排序算法”</h1><h2 id="排序算法的执行效率"><a href="#排序算法的执行效率" class="headerlink" title="排序算法的执行效率"></a>排序算法的执行效率</h2><ul><li><ol><li>最好情况、最坏情况、平均情况时间复杂度</li></ol></li><li><ol start="2"><li>时间复杂度的系数、常数、低阶</li></ol></li><li><ol start="3"><li>比较次数和交换（或移动）次数</li></ol></li></ul><h2 id="排序算法的内存消耗"><a href="#排序算法的内存消耗" class="headerlink" title="排序算法的内存消耗"></a>排序算法的内存消耗</h2><p>排序算法的内存消耗可以用空间复杂度来衡量，我们还引入了一个叫<code>原地排序</code>的概念，就是空间复杂度是O(1)的排序算法。</p><h2 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h2><p><code>稳定性</code>,这个概念指的是如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p><p>一个例子，假如 2，9，3，4，8，3 在排序后就是 2，3，3，4，5，8，9<br>这个例子中如果两个<code>3</code>顺序变了，那么就不稳定，反之稳定。</p><blockquote><p>这是为什么呢？ 平时学习算法过程中，我总用整数来进行表示这些。<br>但是假如说给一个开发的场景，比如给一个<code>订单</code>进行排序，此时<code>10w</code>条数据，我们会希望按照金额从小到大排序。对于金额相同的数据，我们会按照下单时间从早到晚排序。对于这样一个排序需求，如何做？</p></blockquote><p><code>借助稳定排序算法</code>，先按照下单时间进行排序，再按照下单的金额进行排序。此时两遍排序之后，我们使用稳定的排序算法，将不会影响金额相同的两个对象，相同金额相同的订单仍然保持下单时间从早到晚有序。</p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序算法比较好理解，下面贴一下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arr为待排序数组，n为数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr, n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">let</span> boolSort = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n - i -<span class="number">1</span>; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">let</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">                boolSort = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!boolSort) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>冒泡排序是原地排序算法，它只涉及相邻数据的交换操作，只需要常量级的临时空间，所以他的空间复杂度为O(1).</li><li>是稳定的排序算法</li></ul><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr,n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n ; ++i )&#123;</span><br><span class="line">        <span class="keyword">let</span> value = arr[i];</span><br><span class="line">        <span class="keyword">for</span>(j = i - <span class="number">1</span>;j &gt;=<span class="number">0</span>;--j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; value)&#123;</span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+<span class="number">1</span>] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>插入排序是原地排序算法，只需要常量级的临时空间，所以他的空间复杂度为O(1).</li><li>是稳定的排序算法</li></ul><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i+<span class="number">1</span>; j &lt; arr.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[minIndex] )&#123;</span><br><span class="line">                <span class="keyword">let</span> t = arr[j];</span><br><span class="line">                arr[j] = arr[minIndex];</span><br><span class="line">                arr[minIndex] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>选择排序不稳定，他每次都要找到未排序元素的最小值，并和前面元素交换位置，这样破坏了稳定性</li><li>选择排序是原地排序，时间复杂度为O(1)</li></ul><p>解答开篇，由于冒泡排序数据交换要比插入排序的数据移动要复杂。<br>冒泡排序需要三个赋值操作，而插入排序只需要一个赋值操作。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;排序算法太多了，打开Google，搜索&lt;code&gt;排序&lt;/code&gt;二字，出现了好多名字都没听过的，比如猴子排序、睡眠排序、面条排序。&lt;br&gt;今天也就复习一下常用的排序：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。&lt;/p&gt;</summary>
    
    
    
    
    <category term="排序算法" scheme="https://nonentityboy.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>实习感悟(在腾讯与 IBM 实习，我学到了什么？)</title>
    <link href="https://nonentityboy.github.io/2020/02/05/FE_Intern_think/"/>
    <id>https://nonentityboy.github.io/2020/02/05/FE_Intern_think/</id>
    <published>2020-02-05T09:05:07.000Z</published>
    <updated>2021-04-02T12:37:14.819Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我于 2019 年 7 月份开始在腾讯深圳 PCG 实习了两个多月，在 2019 年 10 月份在 IBM 西安实习至今，在此将所学到的知识分享给大家，我的技术栈为前端。</p></blockquote><span id="more"></span><blockquote><p>希望疫情快快过去，天佑武汉，天佑中华。</p></blockquote><p>我大一时候，我看见身边有一名优秀的学长，大二就在腾讯暑期实习。自己也给自己设定了flag，我也要大二暑期去腾讯实习。</p><p>所以在 2019.4 月，我便开始慢慢面试一些公司的日常实习，期间投递了十余家。当然很多公司一听到我是大二的，便没有了下文。</p><p>有面试之后的实习offer战绩：<br>金山云(二面挂)、搜狗(offer)、网易(offer)、百度(挂过一个部门后又拿了一个部门的offer)、腾讯(IEG挂，PCG offer)，美团(一面挂)。</p><p>2019.9月，大三这学期实验课程非常多，不好安排，所以在腾讯离职了。</p><p>在腾讯这两个月，自己身心也非常的累，自己一直也是象牙塔里面的学生，腾讯的企业文化与生活节奏，使我学习到了非常多的东西（无论是技术上还是见识上）。</p><p>2019.9月底，我开始筹划找11月份的实习，因为那时候实验课比较少。</p><p>战绩：微软(三面挂)，IBM(offer)</p><h1 id="满腔热血"><a href="#满腔热血" class="headerlink" title="满腔热血"></a>满腔热血</h1><p>2019.5 月，我收到了腾讯PCG 2019年暑期实习offer(实际上我在官网投递的是日常实习，后来被暑期实习捞了)，当我本人拿到offer那一瞬间，自己脑子里期盼着即将去公司大展宏图。</p><p>我十分开心，于是也在 7 月开始了自己的深圳之旅。</p><p><img src="/2020/02/05/FE_Intern_think/tencent.jpg" alt="tencent.jpg"></p><h1 id="直面失意"><a href="#直面失意" class="headerlink" title="直面失意"></a>直面失意</h1><p>入职第一天，我被配环境折腾得毫无动力，配了一下午，内心爆炸。</p><p>后来导师的帮助（轻车熟路的十分钟）下，我顺利配完了环境。</p><p>之后在做项目组分配的项目时，自己也更是觉得自己太菜了，周围同事都十分厉害，而我却干啥都不够格。</p><h1 id="不要瞎折腾，多问，及时反馈进度"><a href="#不要瞎折腾，多问，及时反馈进度" class="headerlink" title="不要瞎折腾，多问，及时反馈进度"></a>不要瞎折腾，多问，及时反馈进度</h1><h2 id="在腾讯时"><a href="#在腾讯时" class="headerlink" title="在腾讯时"></a>在腾讯时</h2><p>一开始，我在遇到问题的时候，总喜欢一个人闷头搞，在内网搜文章，搜解决方法，顺着 英文id 在企业微信上私聊其它人（却没有问导师），然而远程解决问题，根本难以真正解决，最终导致自己效率极其低下。</p><p>由于我一直怕影响导师，我看他每天都特别忙（同事、总监、leader各种事情叫他）。</p><p>内心想：“我这样烦导师，会不会不太好啊？”我在与导师谈心的时候聊过这个问题，他的回答让我放下了担忧：“是很烦啊！但是谁不是这样过来的呢？” 是啊，谁不是麻烦别人指导过来的呢？ <code>前辈们也都是通情达理的人，只要遇到问题及时请教前辈们，他们也都会包容你的。</code></p><p>后来我开始有问题可以先查，短时间突然解决不了，就直接向导师或者其他前辈寻求帮助。</p><p>我自己有一个良好的习惯，那就是<code>及时给导师或者项目组leader反馈的自己进度</code>。</p><h2 id="在IBM时"><a href="#在IBM时" class="headerlink" title="在IBM时"></a>在IBM时</h2><p>由于我已经之前有一份实习经历，也是比较有经验的，在IBM时，<code>入职第一天我便快速上手开发</code>，而且我自己在日常开发项目过程中，我觉得我的开发效率是和正式员工相同的。</p><p>在 IBM 时候，我平常喜欢看内网 learning 里面的一些东西，学习一些自己喜欢的知识，以及 IBM 的历史。</p><p><img src="/2020/02/05/FE_Intern_think/ibm.jpg" alt="ibm"></p><h1 id="让别人觉得你靠谱"><a href="#让别人觉得你靠谱" class="headerlink" title="让别人觉得你靠谱"></a>让别人觉得你靠谱</h1><ul><li><code>以正式员工要求自己</code> 与别人交流时不要总担心问题太愚蠢。以一种平等的身份去与人交流，效率就会高很多。当我破除了内心给自己预设的「实习生」枷锁后，我真真切切地感受到了自己思维和态度上的提升。毕竟一名优秀的实习生就是未来的正式员工， <code>与其让时间推动你的成长，不如突破自我设限，以先入为主态度来要求自己。</code></li><li><code>让别人能经常得到你的反馈。</code> 实习生一般都会要求写日报，这就是为了让导师能及时了解你当前的状态。同理，我们在与他人合作时，最好定期主动汇报当前的开发进度，让别人能感受到你正在做事。在开发过程中遇到了问题，及时提出问题并附上自己的思考，让别人了解你面对问题是会主动思考的。如果你不主动去反馈，等别人想起你来催你的话，你就可能会被打上<code>「挤牙膏」</code>的印象。</li><li><code>不轻易做承诺，但承诺必行。</code> 承诺是给别人的定心丸，它的说服力取决于别人是否认为你可靠。而一个满嘴跑火车给承诺的人基本上是不可靠的。同时言出必行是我们营造可靠印象的最佳方式。在公司内，如果一个需求流转到你这里了要进行排期，请给自己预留充足的时间。打比方说一个需求你最终做完需要3天时间，但你当时答应的是两天出货，别人就会认为你不靠谱，但如果你当时答应的是4天，那你就是超出预期。结果虽然相同，但给别人的印象却截然不同。如果在做需求的过程中发现的确做不完了，一定要第一时间反馈给大家，及时采取措施来确保需求顺利完成。如果你选择死扛到上线前一天再说做不完了，造成的损失就不只是别人对你的印象了。</li><li><code>先规划好，再去行动。</code> 在公司内，比较大的需求都会进行评审，这就是为了让大家对整个需求的流程有一个理解和规划。抛离需求不谈，我们在日常写代码之前也应该有这样的前奏。做任何事前先把开发规划做出来，然后给导师审阅。这样其一是可以让导师及时纠正你逻辑的不足之处，其二是可以让导师了解你的思维。</li><li><code>要有团队意识</code> 开发过程中，代码质量，注释的编写，写代码一定要尽可能的去考虑他人感受。多人协作，某些有特定功能的代码都需要清楚注释。同理，如果有一个新 feature 实现了，最好跟进一份文档，来让大家都能弄明白使用方式。</li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>2019 这一年，也是我褪去学生气的一年。<br>2020 也希望自己能成为一名合格的前端工程师。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;我于 2019 年 7 月份开始在腾讯深圳 PCG 实习了两个多月，在 2019 年 10 月份在 IBM 西安实习至今，在此将所学到的知识分享给大家，我的技术栈为前端。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="随笔" scheme="https://nonentityboy.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Vue内部运行机制</title>
    <link href="https://nonentityboy.github.io/2020/02/04/Vue%E5%86%85%E9%83%A8%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>https://nonentityboy.github.io/2020/02/04/Vue%E5%86%85%E9%83%A8%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</id>
    <published>2020-02-04T10:21:42.000Z</published>
    <updated>2020-06-20T16:45:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>对Vue.js进行一个概念梳理的过程。</p><span id="more"></span><h1 id="全局概览"><a href="#全局概览" class="headerlink" title="全局概览"></a>全局概览</h1><p>流程图如下：</p><p><img src="/2020/02/04/Vue%E5%86%85%E9%83%A8%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/quanju.jpg" alt="image"></p><h1 id="初始化及挂载"><a href="#初始化及挂载" class="headerlink" title="初始化及挂载"></a>初始化及挂载</h1><p><img src="/2020/02/04/Vue%E5%86%85%E9%83%A8%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/chushi.jpg" alt="image"><br>在 <code>new Vue()</code>后,Vue会调用 <code>_init</code> 函数进行初始化，也就是这里的 <code>init</code> 过程。</p><p>会生成生命周期、事件、props、methods、data、computed 与 watch 等。<br>其中最重要的是通过 Object.defineProperty 设置 setter 和 getter函数，实现<code>响应式</code>及<code>依赖收集</code>。</p><p>初始化后调用<code>$mount</code>会挂载组件。<br>如果是运行时编译，即不存在 render function 但是存在template的情况，需要进行编译步骤。</p><h1 id="编译-："><a href="#编译-：" class="headerlink" title="编译 ："></a>编译 ：</h1><p>compile编译可分成 parse optimize generate 三个阶段，最终需要得到 render function</p><h2 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h2><p>会用正则等方式解析 template 模板中的指令、class、style登数据，形成AST</p><h2 id="optimize"><a href="#optimize" class="headerlink" title="optimize"></a>optimize</h2><p>主要作用是标记 static 静态节点，这是 Vue 在编译过程中的一处优化，后面当 update 更新界面时，会有一个 patch 的过程， diff 算法会直接跳过静态节点，从而减少了比较的过程，优化了 patch 的性能。</p><h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><p>将AST 转化为 render function 字符串的过程，得到的结果是 render 字符串以及 staticRenderFns字符串</p><p>在经历过 parse optimize 与 generate 三个阶段后，组件中就会存在渲染VNode所需的  render function</p><h1 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h1><p><img src="/2020/02/04/Vue%E5%86%85%E9%83%A8%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/xiangying.ipg.jpg" alt="xiangying"></p><p>这里的 getter 和 setter 已经在上面介绍过，在 init 时候通过 Object.defineProperty 进行了绑定，它使得当被设置的对象被读取的时候会执行 getter 函数 ，而在当被赋值的时候会执行 setter 函数。</p><p>当 render funticon 被渲染的时候，因为会读取所需对象的值，所以会出发 getter 函数进行 <code>依赖收集</code>，<code>依赖收集</code>的目的是将观察者Watcher对象存放到当前闭包中的订阅者Dep 的 subs 中。<br>形成如下关系：</p><p><img src="/2020/02/04/Vue%E5%86%85%E9%83%A8%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/object.jpg" alt="image"></p><p>在修改对象的值的时候，会触发 setter, setter通知之前 <code>&quot;依赖收集&quot;</code>得到的Dep中的每一个Watcher, 告诉他们自己的值改变了。</p><p>需要重新渲染视图，这时候这些 Watcher 就会开始调用 Update 来更新视图，当然这中间还有一个 <code>patch</code> 的过程以及<code>使用队列来异步更新的策略</code>。</p><h1 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h1><p>render function 会被转化为VNode节点。 Virtual DOM其实就是一颗 JS对象（VNode节点）作为基础的树，用对象属性来描述节点，实际上，实际上它是一层对真实DOM的抽象。</p><p>最终可以通过一系列操作使这颗树映射到真实环境上。</p><p>由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。</p><p>比如说下面这样一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    tag: <span class="string">&#x27;div&#x27;</span>,                 <span class="comment">/*说明这是一个div标签*/</span></span><br><span class="line">    children: [                 <span class="comment">/*存放该标签的子节点*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            tag: <span class="string">&#x27;a&#x27;</span>,           <span class="comment">/*说明这是一个a标签*/</span></span><br><span class="line">            text: <span class="string">&#x27;click me&#x27;</span>    <span class="comment">/*标签的内容*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染后可以得到</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这只是一个简单的例子，实际上的节点有更多的属性来标志节点，比如 isStatic （代表是否为静态节点）、 isComment （代表是否为注释节点）等。</p><h1 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h1><p><img src="/2020/02/04/Vue%E5%86%85%E9%83%A8%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/gengxin.jpg" alt="image"></p><p>在修改一个对象值的时候，会通过 setter &gt; watcher &gt; update 的流程来修改对应的视图，那么最终如何更新视图呢？</p><p>当数据变化后，执行 render function 就可以得到一个新的 VNode 节点，我们如果想要得到新的视图，最简单粗暴的方法就是直接解析这个新的 VNode 节点 ， 然后用 innerHTML 直接全部渲染到真实DOM中。</p><p>但是！！！其实我们只对其中的一小块内容进行了修改，这样做有些<code>浪费</code>。</p><p>patch 就只修改那些 <code>改变了的地方</code>。<br>我们将新的VNode 与旧的 VNode 一起传入 进行<code>patch</code>比较，经过diff算法 得出他们的 <code>差异</code>，最后我们只需要将这些差异的对应DOM进行修改即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对Vue.js进行一个概念梳理的过程。&lt;/p&gt;</summary>
    
    
    
    
    <category term="前端框架" scheme="https://nonentityboy.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>如何实现LRU缓存淘汰算法</title>
    <link href="https://nonentityboy.github.io/2020/02/03/Linklist-LRU/"/>
    <id>https://nonentityboy.github.io/2020/02/03/Linklist-LRU/</id>
    <published>2020-02-03T09:13:24.000Z</published>
    <updated>2020-02-03T12:37:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>先讨论一个经典的链表应用场景 , 那就是LRU缓存淘汰算法.</p><span id="more"></span><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>缓存是一种高数据读取性能的技术,有着非常广泛的应用.<br>常见的: CPU缓存 数据库缓存 浏览器缓存</p><p>缓存大小有限,当缓存被用满时,哪些数据应该被清理出去,哪些数据应该被保留.<br>需要缓存淘汰策略来决定:</p><p>常见策略有:</p><ul><li>先进先出策略FIFO</li><li>最少使用策略LFU</li><li>最近最少使用策略LRU</li></ul><p>打个比方,比如买了一堆书,有一天发现书太多了,需要扔一部分.那么就可以选择上面的策略.</p><h1 id="五花八门的链表结构"><a href="#五花八门的链表结构" class="headerlink" title="五花八门的链表结构"></a>五花八门的链表结构</h1><h2 id="底层存储结构"><a href="#底层存储结构" class="headerlink" title="底层存储结构"></a>底层存储结构</h2><p><img src="/2020/02/03/Linklist-LRU/array&amp;linklist.jpg" alt="array&amp;linklist"><br>数组:数组需要一块<code>连续的内存空间</code>来存储,对内存的要求是比较高.如果我们申请了一个100MBda大小的数组,当内存中没有<code>连续的 足够的大</code>的存储空间时候,即便内存的剩余总可用空间大于100MB,仍然会申请失败.</p><p>链表:不需要一块连续的内存空间,通过指针将一组<code>零散的内存块</code>串联起来使用,如果我们申请100MB大小的链表,根本不会有问题.</p><h2 id="单链表-双链表-循环链表"><a href="#单链表-双链表-循环链表" class="headerlink" title="单链表 双链表 循环链表"></a>单链表 双链表 循环链表</h2><p><img src="/2020/02/03/Linklist-LRU/Snipaste_2020-02-03_20-32-59.jpg" alt="array&amp;linklist"></p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>链表通过指针将一组零散的内存块串联一起, 把内存块称之为链表的<code>结点</code>.</p><p>为了将所有的结点串起来, 每个链表的结点除了存储数据之外,还需要记录链上下一个结点的地址.如图所示, 我们把记录下一个结点地址的指针叫<code>后继指针next</code>.</p><p>上图有两个结点比较特殊,<code>第一个结点(头结点)</code>和<code>最后一个结点(尾结点)</code></p><p>其中头结点为记录链表的基地址,有了它,就可以遍历整条结点.而尾结点是直接指向一个<code>空地址NULL</code>,表示这是链表上最后一个结点</p><h3 id="单链表的插入-查找-删除"><a href="#单链表的插入-查找-删除" class="headerlink" title="单链表的插入 查找 删除"></a>单链表的插入 查找 删除</h3><p><img src="/2020/02/03/Linklist-LRU/Snipaste_2020-02-03_20-33-10.jpg" alt="array&amp;linklist"></p><p><code>数组的插入和删除</code>时,为了保持内存数据的连续性,需要做大量的数据搬移,此时时间复杂度为O(n).</p><p><code>链表的插入和删除</code>时,只需要考虑相邻结点的指针改变,所以此时时间复杂度为O(1)</p><p>有利有弊,链表要随机访问第k个元素,就没有数组那么高效.链表中的数据并非连续存储,没有办法像数组那样根据首地址和下表,通过寻址公式就能直接计算出对应的内存地址,而是需要根据指针一个结点一个结点进行一次遍历,去找到相应的结点.</p><blockquote><p>把链表想象成一个队伍,队伍中每个人都知道自己后面的人是谁,所以当我们希望指导排在第k个人是谁,就需要一个一个遍历. 需要O(n)时间复杂度.</p></blockquote><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p><img src="/2020/02/03/Linklist-LRU/Snipaste_2020-02-03_20-33-20.jpg" alt="image"><br>循环链表是一种特殊的单链表,唯一的区别是,循环链表的尾结点指向头结点.</p><p>有一个著名的<code>约瑟夫问题</code></p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p><img src="/2020/02/03/Linklist-LRU/Snipaste_2020-02-03_20-33-30.jpg" alt="image"><br>支持两个方向,结点还有个<code>前驱指针prev</code>指向前面的结点</p><p>双向链表和单向链表的区别:</p><ul><li><ol><li>双向链表比单链表占用更多的内存空间,但可支持双向遍历,这样带来了双向链表操作的灵活性</li></ol></li><li><ol start="2"><li>从结构上来看双向链表支持O(1)时间复杂度的情况下找到前驱节点,使得某些情况下,插入 删除操作更高效 简单.</li></ol></li></ul><h3 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h3><p><img src="/2020/02/03/Linklist-LRU/Snipaste_2020-02-03_20-33-43.jpg" alt="image"></p><h2 id="链表-数组性能比拼"><a href="#链表-数组性能比拼" class="headerlink" title="链表/数组性能比拼"></a>链表/数组性能比拼</h2><table><thead><tr><th>时间复杂度</th><th>数组</th><th>链表</th></tr></thead><tbody><tr><td>插入删除</td><td>O(n)</td><td>O(1)</td></tr><tr><td>随机访问</td><td>O(1)</td><td>O(n)</td></tr></tbody></table><h1 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h1><p>基于链表实现LRU缓存淘汰算法?</p><p>思路: 维护一个有序的单链表,越靠近链表尾部的结点是越早之前访问的,当有新的数据被访问时,我们从链表头开始顺序遍历链表.</p><ol><li>如果此数据之前已经存在链表中,我们遍历得到这个数据对应的结点,将其从原来的位置删除,再插入到链表头部.</li><li>如果此时数据没有在缓存链表中,分为两种情况<ul><li>缓存未满,此结点插入到链表的头部</li><li>缓存已满,链表尾结点删除,将新的数据结点插入链表的头部.</li></ul></li></ol><p>时间复杂度: 无论缓存有没有满,都必须遍历一遍链表,所以这种基于链表实现的思路,时间复杂度为O(n)</p><blockquote><p>实际上也可以用<code>散列表</code>来记录每个数据的位置,将缓存访问的时间复杂度降到O(1).</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;先讨论一个经典的链表应用场景 , 那就是LRU缓存淘汰算法.&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据结构" scheme="https://nonentityboy.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>为什么很多编程语言中数组从0开始编号</title>
    <link href="https://nonentityboy.github.io/2020/02/03/Array-From-1/"/>
    <id>https://nonentityboy.github.io/2020/02/03/Array-From-1/</id>
    <published>2020-02-03T02:25:20.000Z</published>
    <updated>2020-02-06T14:43:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>为什么很多编程语言中数组从0开始编号？而不是从1呢？ 从1开始不是更符合人类的思维习惯吗？<br><span id="more"></span></p><h1 id="什么是数组？"><a href="#什么是数组？" class="headerlink" title="什么是数组？"></a>什么是数组？</h1><p>数组（Array）是一种<code>线性表</code>数据结构，它用一组<code>连续的内存空间</code>，来存储一组有<code>相同类型</code>的数据。</p><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>顾名思义，线性表就是数据排成一条线一样的结构，每个线性表最多只有<code>前</code>和<code>后</code>两个方向。</p><p>除了数组，链表、队列、栈也是<code>线性表结构</code>。</p><p><img src="/2020/02/03/Array-From-1/Snipaste_2020-02-03_20-23-01.jpg" alt="image"></p><h3 id="非线性表"><a href="#非线性表" class="headerlink" title="非线性表"></a>非线性表</h3><p>比如二叉树、堆、图等。之所以是非线性，因为里面数据之间并<code>不是简单的前后关系</code>。<br><img src="/2020/02/03/Array-From-1/Snipaste_2020-02-03_20-23-34.jpg" alt="image"></p><h2 id="连续的内存空间和相同类型的数据"><a href="#连续的内存空间和相同类型的数据" class="headerlink" title="连续的内存空间和相同类型的数据"></a>连续的内存空间和相同类型的数据</h2><p>这两个特性给了数组一个杀手锏的特性：<code>随机访问</code>。</p><p>有利有弊，这两个限制让数组很多操作<code>非常低效</code>。<br>比如在数组<code>添加或删除一个数据</code>，为了保证<code>连续性</code>，需要大量的<code>数据搬移</code>工作。</p><h2 id="如何根据下标随机访问数组元素"><a href="#如何根据下标随机访问数组元素" class="headerlink" title="如何根据下标随机访问数组元素"></a>如何根据下标随机访问数组元素</h2><p>计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。<br>当计算机需要随机访问数组中的某个元素时，通过下面的寻址公式，计算出该元素存储的内存地址。</p><p>根据寻址公式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i]_address &#x3D; base_address + i * data_type_size</span><br></pre></td></tr></table></figure><p>比如C语言, 且此时为int类型。此时data_type_size为4个字节。</p><h3 id="纠正错误"><a href="#纠正错误" class="headerlink" title="纠正错误"></a>纠正错误</h3><p>链表适合插入、删除、时间复杂度为O(1)，数组适合查找，查找复杂度为O(1)</p><p>正确表达是：<br>数组支持随机访问，根据下表随机访问的时间复杂度为O(1)</p><h2 id="低效的插入和删除"><a href="#低效的插入和删除" class="headerlink" title="低效的插入和删除"></a>低效的插入和删除</h2><p>如果在数组的开头插入数据，此时时间复杂度为O(n)<br>如果在数组的尾部插入数据，此时时间复杂度为O(1)</p><p>因为我们在每个位置插入元素的概率是一样的。<br>平均时间复杂度：(1 + 2 + 3 +  … + n) / n = O(n)</p><p>如果说数组有序，我们在某个位置插入一个新的元素，就必须按照上面的方法搬移k之后的数据。</p><p>如果数组中存储的数据并没任何规律，此时要将某个数组插入到第k个位置，为了避免大规模的数据搬移，还有个简单的办法是，直接将第k位的数据半到数组元素的最后，把新的元素直接放入第k个位置。<br>此时在第k个位置插入一个元素的时间复杂度为O(1)</p><p><img src="/2020/02/03/Array-From-1/Snipaste_2020-02-03_20-23-57.jpg" alt="image"></p><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>与添加操作类似</p><h2 id="警惕数组访问越界"><a href="#警惕数组访问越界" class="headerlink" title="警惕数组访问越界"></a>警惕数组访问越界</h2><h2 id="容器是否能完全替代数组"><a href="#容器是否能完全替代数组" class="headerlink" title="容器是否能完全替代数组"></a>容器是否能完全替代数组</h2><p>ArrayList可以将<code>数组操作的细节封装起来</code>，且支持<code>动态扩容</code>。</p><p>大部分方法的话，比如申请了一个大小为10的数组，当第11个数据需要存储到数组中，我们就重新分配一块更大的空间，将原来的数据复制过去，再将新的数据插入。</p><p>但扩容操作涉及内存申请和数据搬移，是比较耗时的，所以最好实现确定需要存储的数据大小。</p><p>总结一下：业务开发用容器省时省力，会损失一些性能。但完全不会影响到系统整体的性能。<br>若是开发底层的，比如并发网络框架，性能的优化就必须要做到极致。</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>数组存储的内存模型上，”下标”k 就是”偏移（offset）”</p><p>寻址公式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address &#x3D; base_address + k * type_size</span><br></pre></td></tr></table></figure></p><p>但要是按照从1开始计数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address &#x3D; base_address + (k-1) * type_size</span><br></pre></td></tr></table></figure><br>此时多了一条减法指令, CPU就多执行一次减法运算. 所以最好从0开始编号.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;为什么很多编程语言中数组从0开始编号？而不是从1呢？ 从1开始不是更符合人类的思维习惯吗？&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据结构" scheme="https://nonentityboy.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>前端知识点巩固（一）</title>
    <link href="https://nonentityboy.github.io/2020/02/03/FE-Study-Again-1/"/>
    <id>https://nonentityboy.github.io/2020/02/03/FE-Study-Again-1/</id>
    <published>2020-02-02T16:10:45.000Z</published>
    <updated>2020-02-04T15:46:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>接下来我将会把前端知识点进行滚动复习，预计前端知识点巩固共有五篇。<br>目的为夯实基础，梳理知识脉络。</p><span id="more"></span><h1 id="如何理解EventLoop——宏任务和微任务篇"><a href="#如何理解EventLoop——宏任务和微任务篇" class="headerlink" title="如何理解EventLoop——宏任务和微任务篇"></a>如何理解EventLoop——宏任务和微任务篇</h1><h2 id="宏任务-MacroTask-引入"><a href="#宏任务-MacroTask-引入" class="headerlink" title="宏任务(MacroTask)引入"></a>宏任务(MacroTask)引入</h2><p>大部分的任务都是在主线程上执行，常见的任务有:</p><ul><li>渲染事件</li><li>用户交互事件</li><li>js脚本执行</li><li>网络请求、文件读写完成事件等</li></ul><p>为了让这些事件有条不紊地进行，JS引擎需要对之执行的顺序做一定的安排，<code>V8</code> 其实采用的是一种队列的方式来存储这些任务， 即<code>先进来的先执行</code>。模拟如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bool keep_running = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">MainTherad</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">//执行队列中的任务</span></span><br><span class="line">    Task task = task_queue.takeTask();</span><br><span class="line">    ProcessTask(task);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//执行延迟队列中的任务</span></span><br><span class="line">    ProcessDelayTask()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!keep_running) <span class="comment">//如果设置了退出标志，那么直接退出线程循环</span></span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到了一个 for 循环，将队列中的任务一一取出，然后执行，这个很好理解。但是其中包含了<code>两种任务队列</code>，除了上述提到的任务队列， 还有一个<code>延迟队列</code>，它专门处理诸如setTimeout/setInterval这样的定时器回调任务。</p><blockquote><p>普通任务队列和延迟队列中的任务，都属于宏任务。</p></blockquote><h2 id="微任务-MicroTask-引入"><a href="#微任务-MicroTask-引入" class="headerlink" title="微任务(MicroTask)引入"></a>微任务(MicroTask)引入</h2><p>对于每个宏任务而言，其内部都有一个<code>微任务队列</code>。</p><p>其实引入微任务的初衷是为了<code>解决异步回调的问题</code>。想一想，对于异步回调的处理，有多少种方式？总结起来有两点:</p><ul><li>1.将异步回调进行宏任务队列的入队操作。</li><li>2.将异步回调放到当前宏任务的末尾。</li></ul><p>采用第一种方式，执行回调的时机应该是在前面<code>所有的宏任务完成之后</code>，倘若现在的<code>任务队列非常长</code>，那么回调迟迟得不到执行，造成<code>应用卡顿</code>。<br>为了规避这样的问题，<code>V8</code> 引入了第二种方式，这就是<code>微任务的解决方式</code>。在<code>每一个宏任务中定义一个微任务队列</code>，当该<code>宏任务执行完成</code>，会<code>检查</code>其中的<code>微任务队列</code>，如果<code>为空则直接执行下一个宏任务</code>，如果<code>不为空</code>，则<code>依次执行微任务</code>，<code>微任务执行完成</code>才去执行下一个宏任务。</p><p>常见的微任务有:</p><ul><li>MutationObserver</li><li>Promise.then(或.reject) </li><li>以 Promise 为基础开发的其他技术(比如fetch API), </li><li>V8 的垃圾回收过程。</li></ul><h1 id="理解EventLoop——浏览器篇"><a href="#理解EventLoop——浏览器篇" class="headerlink" title="理解EventLoop——浏览器篇"></a>理解EventLoop——浏览器篇</h1><p>上demo:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;start&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timeout&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;resolve&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;end&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 执行宏任务，同步代码直接执行，打印 start ,end</span></span><br><span class="line"><span class="comment">    2. 将setTimeout放到宏任务队列。</span></span><br><span class="line"><span class="comment">    3. Promise.then放入微任务队列。此时当前宏任务队列执行完了。</span></span><br><span class="line"><span class="comment">        检查微任务队列，并依次执行。打印 resolve</span></span><br><span class="line"><span class="comment">    4. 检查宏任务队列，里面有setTimeout，打印timeout.</span></span><br><span class="line"><span class="comment">结果：start -&gt; end -&gt; resolve -&gt; timeout</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这样就带大家直观地感受到了浏览器环境下 EventLoop 的执行流程。不过，这只是其中的一部分情况，接下来我们来做一个更完整的总结。</p><ul><li>一开始整段脚本作为第一个宏任务执行</li><li>执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列</li><li>当前宏任务执行完出队，检查微任务队列，如果有则依次执行，直到微任务队列为空</li><li>执行浏览器 UI 线程的渲染工作</li><li>检查是否有Web worker任务，有则执行</li><li>执行队首新的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Promise1&#x27;</span>)  </span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout2&#x27;</span>)</span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout1&#x27;</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Promise2&#x27;</span>)    </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// start Promise1 setTimeout1 Promise2 setTimeout2</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async2 end&#x27;</span>)</span><br><span class="line">    <span class="comment">// Promise.resolve() 将代码插⼊微任务队列尾部</span></span><br><span class="line">    <span class="comment">// resolve 再次插⼊微任务队列尾部</span></span><br><span class="line">    resolve(<span class="built_in">Promise</span>.resolve())</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// async function async1() &#123;</span></span><br><span class="line"><span class="comment">//     await async2()</span></span><br><span class="line"><span class="comment">//     console.log(&#x27;async1 end&#x27;)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// async function async2() &#123;</span></span><br><span class="line"><span class="comment">//     console.log(&#x27;async2 end&#x27;)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// async1()</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Promise&#x27;</span>)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;接下来我将会把前端知识点进行滚动复习，预计前端知识点巩固共有五篇。&lt;br&gt;目的为夯实基础，梳理知识脉络。&lt;/p&gt;</summary>
    
    
    
    
    <category term="前端基础" scheme="https://nonentityboy.github.io/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>深入挖掘JavaScript内存机制</title>
    <link href="https://nonentityboy.github.io/2019/12/05/JS_Memory_mechanism/"/>
    <id>https://nonentityboy.github.io/2019/12/05/JS_Memory_mechanism/</id>
    <published>2019-12-05T11:58:00.000Z</published>
    <updated>2019-12-05T14:22:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>先抛出一个问题？JS中数据如何存储。<br>基本数据类型用栈存储，引用数据类型用堆存储。<br>看起来没毛病，实际上是需要考虑闭包的情况。如果变量存在栈中，<code>函数调用完栈顶空间销毁</code>，闭包变量(闭包变量存在堆内存中)不就没了吗？<br><span id="more"></span></p><p>具体而言：以下数据类型存储在栈中：</p><ul><li>boolean</li><li>null</li><li>undefined</li><li>number</li><li>string</li><li>symbol</li><li>bigint<blockquote><p>所有的对象数据类型存放在堆中</p></blockquote></li></ul><p>而值得注意的是，对于赋值操作，原始类型的数据直接完整地复制变量值，对象数据类型的数据则是复制引用地址。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> newObj = obj;</span><br><span class="line">newObj.a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a);<span class="comment">//变成了2</span></span><br></pre></td></tr></table></figure><p>obj 和 newObj 是同一份堆空间的地址，改变newObj，等于改变了共同的堆内存，这时候通过 obj 来获取这块内存的值当然会改变。</p><h3 id="为什么不全部用栈来保存呢？"><a href="#为什么不全部用栈来保存呢？" class="headerlink" title="为什么不全部用栈来保存呢？"></a>为什么不全部用栈来保存呢？</h3><p>首先，对于系统栈来说，它的功能除了保存变量之外，还有创建并切换函数执行上下文的功能。举个例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  f(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><h3 id="假设用ESP指针来保存当前的执行状态，在系统栈中会产生如下的过程："><a href="#假设用ESP指针来保存当前的执行状态，在系统栈中会产生如下的过程：" class="headerlink" title="假设用ESP指针来保存当前的执行状态，在系统栈中会产生如下的过程："></a>假设用ESP指针来保存当前的执行状态，在系统栈中会产生如下的过程：</h3><ul><li><p>调用func, 将 func 函数的上下文压栈，ESP指向栈顶。</p></li><li><p>执行func，又调用f函数，将 f 函数的上下文压栈，ESP 指针上移。</p></li><li><p>执行完 f 函数，将ESP 下移，f函数对应的栈顶空间被回收。</p></li><li><p>执行完 func，ESP 下移，func对应的空间被回收。</p></li></ul><p><img src="https://ketingl-1256819531.cos.ap-chengdu.myqcloud.com/myblog/Memory_mechanism/1.jpg" alt="image"></p><p>你也看到了，如果采用栈来存储相对基本类型更加复杂的对象数据，那么切换上下文的开销将变得巨大！</p><p>不过堆内存虽然空间大，能存放大量的数据，但与此同时垃圾内存的回收会带来更大的开销,下来就来分析一下堆内存到底是如何进行垃圾回收并进行优化的。</p><h3 id="V8-引擎如何进行垃圾内存的回收？"><a href="#V8-引擎如何进行垃圾内存的回收？" class="headerlink" title="V8 引擎如何进行垃圾内存的回收？"></a>V8 引擎如何进行垃圾内存的回收？</h3><p>JS 语言不像 C/C++, 让程序员自己去开辟或者释放内存,而是采用自己的一套垃圾回收算法进行自动的内存管理。</p><h4 id="V8-内存限制"><a href="#V8-内存限制" class="headerlink" title="V8 内存限制"></a>V8 内存限制</h4><p>V8只能使用系统的一部分内存，具体来说，在64位系统下，V8最多只能分配1.4G, 在 32 位系统中，最多只能分配0.7G。你想想在前端这样的大内存需求其实并不大，但对于后端而言，nodejs如果遇到一个2G多的文件，那么将无法全部将其读入内存进行各种操作了。</p><p>栈内存而言，当ESP指针下移，也就是上下文切换之后，栈顶的空间会自动被回收。但对于堆内存而言就比较复杂了，我们下面着重分析堆内存的垃圾回收。</p><p>上面提到过，所有的对象类型的数据在JS中都是通过堆进行空间分配的。当我们构造一个对象进行赋值操作的时候，其实相应的内存已经分配到了堆上。你可以不断的这样创建对象，让 V8 为它分配空间，直到堆的大小达到上限。</p><h4 id="V8-为什么要给它设置内存上限？明明我的机器大几十G的内存，只能让我用这么一点？"><a href="#V8-为什么要给它设置内存上限？明明我的机器大几十G的内存，只能让我用这么一点？" class="headerlink" title="V8 为什么要给它设置内存上限？明明我的机器大几十G的内存，只能让我用这么一点？"></a>V8 为什么要给它设置内存上限？明明我的机器大几十G的内存，只能让我用这么一点？</h4><p>究其根本，是由两个因素所共同决定的，一个是JS单线程的执行机制，另一个是JS垃圾回收机制的限制。</p><p>JS是单线程运行的，这意味着一旦进入到垃圾回收，那么其它的各种运行逻辑都要暂停; 另一方面垃圾回收其实是非常耗时间的操作，V8 官方是这样形容的:</p><blockquote><p>以 1.5GB 的垃圾回收堆内存为例，V8 做一次小的垃圾回收需要50ms 以上，做一次非增量式(ps:后面会解释)的垃圾回收甚至要 1s 以上</p></blockquote><p>在这么长的时间内，我们的JS代码执行会一直没有响应，造成应用卡顿，导致应用性能和响应能力直线下降。因此，V8 做了一个简单粗暴的选择，那就是限制堆内存，也算是一种权衡的手段，因为大部分情况是不会遇到操作几个G内存这样的场景的。</p><p>想调整这个内存的限制,配置命令如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是调整老生代这部分的内存，单位是MB。后面会详细介绍新生代和老生代内存</span></span><br><span class="line">node --max-old-space-size=<span class="number">2048</span> xxx.js </span><br></pre></td></tr></table></figure><h3 id="新生代内存的回收"><a href="#新生代内存的回收" class="headerlink" title="新生代内存的回收"></a>新生代内存的回收</h3><p>V8 把堆内存分成了两部分进行处理——新生代内存和老生代内存。顾名思义，新生代就是临时分配的内存，存活时间短， 老生代是常驻内存，存活的时间长。V8 的堆内存，也就是两个内存之和。</p><p><img src="https://ketingl-1256819531.cos.ap-chengdu.myqcloud.com/myblog/Memory_mechanism/2.jpg" alt="image"></p><p>根据这两种不同种类的堆内存，V8 采用了不同的回收策略，来根据不同的场景做针对性的优化。<br>首先是新生代的内存，刚刚已经介绍了调整新生代内存的方法，那它的内存默认限制是多少？在 64 位和 32 位系统下分别为 32MB 和 16MB。够小吧，不过也很好理解，新生代中的变量存活时间短，来了马上就走，不容易产生太大的内存负担，因此可以将它设的足够小。</p><h4 id="新生代的垃圾回收是怎么做的呢？"><a href="#新生代的垃圾回收是怎么做的呢？" class="headerlink" title="新生代的垃圾回收是怎么做的呢？"></a>新生代的垃圾回收是怎么做的呢？</h4><p>先将新生代内存空间一分为二</p><p>其中From部分表示正在使用的内存，To 是目前闲置的内存。</p><p><img src="https://ketingl-1256819531.cos.ap-chengdu.myqcloud.com/myblog/Memory_mechanism/3.jpg" alt="image"></p><p>进行垃圾回收时，V8 将From部分的对象检查一遍，如果是存活对象那么复制到To内存中(在To内存中按照顺序从头放置的)，如果是非存活对象直接回收即可。</p><p>当所有的From中的存活对象按照顺序进入到To内存之后，From 和 To 两者的角色对调，From现在被闲置，To为正在使用，如此循环。<br>那你很可能会问了，直接将非存活对象回收了不就万事大吉了嘛，为什么还要后面的一系列操作？<br>注意，我刚刚特别说明了，在To内存中按照顺序从头放置的，这是为了应对这样的场景:</p><p><img src="https://ketingl-1256819531.cos.ap-chengdu.myqcloud.com/myblog/Memory_mechanism/4.jpg" alt="image"></p><p>深色的小方块代表存活对象，白色部分表示待分配的内存，由于堆内存是连续分配的，这样零零散散的空间可能会导致稍微大一点的对象没有办法进行空间分配，这种零散的空间也叫做内存碎片。刚刚介绍的新生代垃圾回收算法也叫Scavenge算法。</p><p>Scavenge 算法主要就是解决内存碎片的问题，在进行一顿复制之后，To空间变成了这个样子:</p><p><img src="https://ketingl-1256819531.cos.ap-chengdu.myqcloud.com/myblog/Memory_mechanism/5.jpg" alt="image"></p><p>这样就大大方便了后续连续空间的分配。</p><p>不过Scavenge 算法的劣势也非常明显，就是内存只能使用新生代内存的一半，但是它只存放生命周期短的对象，这种对象一般很少，因此时间性能非常优秀。</p><h4 id="老生代内存的回收优势怎么做的？"><a href="#老生代内存的回收优势怎么做的？" class="headerlink" title="老生代内存的回收优势怎么做的？"></a>老生代内存的回收优势怎么做的？</h4><p>刚刚介绍了新生代的回收方式，那么新生代中的变量如果经过多次回收后依然存在，那么就会被放入到老生代内存中，这种现象就叫晋升。</p><p>发生晋升其实不只是这一种原因，我们来梳理一下会有那些情况触发晋升:</p><ul><li>已经经历过一次 Scavenge 回收。</li><li>To（闲置）空间的内存占用超过25%。</li></ul><p>现在进入到老生代的垃圾回收机制当中，老生代中累积的变量空间一般都是很大的，当然不能用Scavenge算法，浪费一半空间不说，对庞大的内存空间进行复制岂不是劳民伤财？</p><p>老生代而言，究竟是采取怎样的策略进行垃圾回收的呢？</p><p>第一步，进行标记-清除。这个过程在《JavaScript高级程序设计(第三版)》中有过详细的介绍，主要分成两个阶段，即标记阶段和清除阶段。首先会遍历堆中的所有对象，对它们做上标记，然后对于代码环境中使用的变量以及被强引用的变量取消标记，剩下的就是要删除的变量了，在随后的清除阶段对其进行空间的回收。<br>当然这又会引发内存碎片的问题，存活对象的空间不连续对后续的空间分配造成障碍。老生代又是如何处理这个问题的呢？</p><p>第二步，整理内存碎片。V8 的解决方式非常简单粗暴，在清除阶段结束后，把存活的对象全部往一端靠拢。</p><p>由于是移动对象，它的执行速度不可能很快，事实上也是整个过程中最耗时间的部分。</p><h4 id="增量标记"><a href="#增量标记" class="headerlink" title="增量标记"></a>增量标记</h4><p>由于JS的单线程机制，V8 在进行垃圾回收的时候，不可避免地会阻塞业务逻辑的执行，倘若老生代的垃圾回收任务很重，那么耗时会非常可怕，严重影响应用的性能。那这个时候为了避免这样问题，V8 采取了增量标记的方案，即将一口气完成的标记任务分为很多小的部分完成，每做完一个小的部分就”歇”一下，就js应用逻辑执行一会儿，然后再执行下面的部分，如果循环，直到标记阶段完成才进入内存碎片的整理上面来。</p><p>经过增量标记之后，垃圾回收过程对JS应用的阻塞时间减少到原来了1 / 6, 可以看到，这是一个非常成功的改进。</p><p>JS垃圾回收的原理最重要的是理解它为什么要这么做，而不仅仅是如何做的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;先抛出一个问题？JS中数据如何存储。&lt;br&gt;基本数据类型用栈存储，引用数据类型用堆存储。&lt;br&gt;看起来没毛病，实际上是需要考虑闭包的情况。如果变量存在栈中，&lt;code&gt;函数调用完栈顶空间销毁&lt;/code&gt;，闭包变量(闭包变量存在堆内存中)不就没了吗？&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>this绑定全面解析</title>
    <link href="https://nonentityboy.github.io/2019/11/28/this/"/>
    <id>https://nonentityboy.github.io/2019/11/28/this/</id>
    <published>2019-11-28T13:52:00.000Z</published>
    <updated>2019-11-28T13:54:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h1><p>函数在代码中<b>被调用的位置</b></p><p>查找方法:<br>分析调用栈(调用位置就是当前正在执行的函数的前一个调用中)<br><span id="more"></span></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当前调用栈是：baz</span></span><br><span class="line">    <span class="comment">// 因此，当前调用位置是全局作用域</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">&quot;baz&quot;</span> );</span><br><span class="line">    bar(); <span class="comment">// &lt;-- bar的调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当前调用栈是：baz --&gt; bar</span></span><br><span class="line">    <span class="comment">// 因此，当前调用位置在baz中</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">&quot;bar&quot;</span> );</span><br><span class="line">    foo(); <span class="comment">// &lt;-- foo的调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当前调用栈是：baz --&gt; bar --&gt; foo</span></span><br><span class="line">    <span class="comment">// 因此，当前调用位置在bar中</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">&quot;foo&quot;</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">baz(); <span class="comment">// &lt;-- baz的调用位置</span></span><br></pre></td></tr></table></figure><p>使用开发者工具的到调用栈：</p><p>设置断点或者插入debugger;<br>语句，运行时调试器会在那个位置暂停，同时展示当前位置的函数调用列表，这就是调用栈。找到栈中的第二个元素，这就是真正的调用位置。</p><h1 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h1><h2 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h2><ul><li>独立函数调用，把默认绑定看作是无法应用其他规则时的默认规则，此时<b>this指向全局对象</b></li><li>严格模式下，this会绑定到undefined。只有函数运行在非严格模式下，默认绑定才能绑定到全局对象。在严格模式下调用函数不影响默认绑定</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 运行在严格模式下，this会绑定到undefined</span></span><br><span class="line"><span class="meta">    &quot;use strict&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">foo(); <span class="comment">// TypeError: Cannot read property &#x27;a&#x27; of undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 运行</span></span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 严格模式下调用函数则不影响默认绑定</span></span><br><span class="line"><span class="meta">    &quot;use strict&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    foo(); <span class="comment">// 2</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h1 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h1><p>当函数引用有上下文对象时，隐式绑定规则会把函数中的this绑定到这个上下文对象。</p><p>对象属性引用链中只有上一层或者说最后一层在调用中起作用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>特定情况下，被隐式绑定的函数特定情况下会丢失绑定对象，导致默认绑定，把this绑定到全局对象或undefined。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虽然bar是obj.foo的一个引用，但是实际上，它引用的是foo函数本身。</span></span><br><span class="line"><span class="comment">// bar()是一个不带任何修饰的函数调用，应用默认绑定。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo; <span class="comment">// 函数别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;oops, global&quot;</span>; <span class="comment">// a是全局对象的属性</span></span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// &quot;oops, global&quot;</span></span><br></pre></td></tr></table></figure><p>参数传递就是一种隐式赋值，传入函数时也会被隐式赋值。回调函数丢失this绑定是非常常见的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFoo</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// fn其实引用的是foo</span></span><br><span class="line">    </span><br><span class="line">    fn(); <span class="comment">// &lt;-- 调用位置！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;oops, global&quot;</span>; <span class="comment">// a是全局对象的属性</span></span><br><span class="line"></span><br><span class="line">doFoo( obj.foo ); <span class="comment">// &quot;oops, global&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// JS环境中内置的setTimeout()函数实现和下面的伪代码类似：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setTimeout</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 等待delay毫秒</span></span><br><span class="line">    fn(); <span class="comment">// &lt;-- 调用位置！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h1><p>call(..) 或者 apply(..)方法。第一个参数是一个对象，在调用函数时将这个对象绑定到this。因为直接指定this的绑定对象，称之为显示绑定。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.call( obj ); <span class="comment">// 2  调用foo时强制把foo的this绑定到obj上</span></span><br></pre></td></tr></table></figure><p>显示绑定无法解决丢失绑定问题。</p><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><ul><li>1.硬绑定</li><li>2.API调用的“上下文”</li></ul><h1 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h1><p>使用new调用函数，或者说发生构造函数调用时，执行操作：</p><ul><li>创建（或者说构造）一个新对象</li><li>这个新对象被执行[[Prototype]]连接</li><li>这个新对象会绑定到函数调用的this</li><li>如果函数没有返回其他对象，new表达式中的函数调用会自动返回这个新对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo(<span class="number">2</span>); <span class="comment">//bar和foo(..)调用的this绑定</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;调用位置&quot;&gt;&lt;a href=&quot;#调用位置&quot; class=&quot;headerlink&quot; title=&quot;调用位置&quot;&gt;&lt;/a&gt;调用位置&lt;/h1&gt;&lt;p&gt;函数在代码中&lt;b&gt;被调用的位置&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;查找方法:&lt;br&gt;分析调用栈(调用位置就是当前正在执行的函数的前一个调用中)&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>从赋值深入深浅拷贝原理</title>
    <link href="https://nonentityboy.github.io/2019/11/25/JS_copy/"/>
    <id>https://nonentityboy.github.io/2019/11/25/JS_copy/</id>
    <published>2019-11-25T12:27:00.000Z</published>
    <updated>2020-06-20T17:00:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>理解: 什么是赋值？<br>将一个数值或对象赋给某个变量的过程。<br><span id="more"></span><br>赋值分两种:</p><ul><li>基本数据类型：赋值后两个变量互不影响</li><li>引用数据类型：赋<b>址</b>,两个变量具有相同的引用，指向同一个对象，相互之间有影响。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&quot;lkt&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// lkt</span></span><br><span class="line"></span><br><span class="line">a = <span class="string">&quot;boy&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// boy</span></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// lkt</span></span><br></pre></td></tr></table></figure><p>对引用类型进行赋址操作，两个变量指向同一个对象，改变变量 a 之后会影响变量 b，哪怕改变的只是对象 a 中的基本类型数据。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    name: <span class="string">&quot;lkt&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;You Don&#x27;t Know JS&quot;</span>,</span><br><span class="line">        price: <span class="string">&quot;45&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;lkt&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line">a.name = <span class="string">&quot;change&quot;</span>;</span><br><span class="line">a.book.price = <span class="string">&quot;55&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;change&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;change&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br></pre></td></tr></table></figure><br>通常在开发中并不希望改变变量 a 之后会影响到变量 b，这时就需要用到浅拷贝和深拷贝。</p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>当我们创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。<br>如果属性是基本类型，拷贝的就是基本类型的值。<br>如果属性是引用类型，拷贝的就是内存地址。<br>所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p><p><img src="http://resource.muyiy.cn/image/2019-07-24-060221.png" alt="123"><br>上图中，SourceObject 是原对象，其中包含基本类型属性 field1 和引用类型属性 refObj。浅拷贝之后基本类型数据 field2 和 filed1 是不同属性，互不影响。但引用类型 refObj 仍然是同一个，改变之后会对另一个对象产生影响。</p><p>实际上就是：浅拷贝只解决了第一层的问题，拷贝第一层的基本类型值，以及第一层的引用类型地址。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    name: <span class="string">&quot;lkt&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;You Don&#x27;t Know JS&quot;</span>,</span><br><span class="line">        price: <span class="string">&quot;45&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;, a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;lkt&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line">a.name = <span class="string">&quot;change&quot;</span>;</span><br><span class="line">a.book.price = <span class="string">&quot;55&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;change&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;lkt&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br></pre></td></tr></table></figure><br>上面代码改变对象 a 之后，对象 b 的基本属性保持不变。但是当改变对象 a 中的对象 book 时，对象 b 相应的位置也发生了变化。</p><p>展开语法 Spread(实际效果和 Object.assign() 是一样的。)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    name: <span class="string">&quot;muyiy&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;You Don&#x27;t Know JS&quot;</span>,</span><br><span class="line">        price: <span class="string">&quot;45&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;...a&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;muyiy&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line">a.name = <span class="string">&quot;change&quot;</span>;</span><br><span class="line">a.book.price = <span class="string">&quot;55&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;change&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;muyiy&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><ul><li>Array.prototype.slice()</li></ul><p>slice() 方法返回一个新的数组对象，这一对象是一个由 begin和 end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">0</span>,<span class="string">&quot;1&quot;</span>,[<span class="number">2</span>,<span class="number">3</span>]];</span><br><span class="line"><span class="keyword">let</span> b = a.slice(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// [&quot;1&quot;,[2,3]]</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">1</span>] = <span class="string">&quot;99&quot;</span>;</span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// [0, &quot;99&quot;, [4, 3]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">//  [&quot;1&quot;, [4, 3]]</span></span><br></pre></td></tr></table></figure><p>改变 a[1] 之后 b[0] 的值并没有发生变化，但改变 a[2][0] 之后，相应的 b[1][0] 的值也发生变化。说明 slice() 方法是浅拷贝，相应的还有concat等，在工作中面对复杂数组结构要额外注意。</p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。</p><p>当对象和它所引用的对象一起拷贝时即发生深拷贝。<br>深拷贝相比于浅拷贝速度较慢并且花销大。（拷贝前后两个对象互不影响）</p><p><img src="http://resource.muyiy.cn/image/2019-07-24-060222.png" alt="image"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    name: <span class="string">&quot;muyiy&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;You Don&#x27;t Know JS&quot;</span>,</span><br><span class="line">        price: <span class="string">&quot;45&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a));</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;muyiy&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line">a.name = <span class="string">&quot;change&quot;</span>;</span><br><span class="line">a.book.price = <span class="string">&quot;55&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;change&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;muyiy&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>完全改变变量 a 之后对 b 没有任何影响，这就是深拷贝的魔力。</p><p>我们看下对数组深拷贝效果如何。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">0</span>, <span class="string">&quot;1&quot;</span>, [<span class="number">2</span>, <span class="number">3</span>]];</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify( a.slice(<span class="number">1</span>) ));</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// [&quot;1&quot;, [2, 3]]</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">1</span>] = <span class="string">&quot;99&quot;</span>;</span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// [0, &quot;99&quot;, [4, 3]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">//  [&quot;1&quot;, [2, 3]]</span></span><br></pre></td></tr></table></figure><p>此方法带来的问题：</p><ol><li>忽略undefined、symbol。</li><li>不能序列化函数</li><li>不能解决循环引用的对象</li><li>不能正确处理new Date()</li><li>不能处理正则</li></ol><p>undefined、symbol 和函数这三种情况，会直接忽略。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;muyiy&#x27;</span>,</span><br><span class="line">    a: <span class="literal">undefined</span>,</span><br><span class="line">    b: <span class="built_in">Symbol</span>(<span class="string">&#x27;muyiy&#x27;</span>),</span><br><span class="line">    c: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;muyiy&quot;, </span></span><br><span class="line"><span class="comment">// a: undefined, </span></span><br><span class="line"><span class="comment">//  b: Symbol(muyiy), </span></span><br><span class="line"><span class="comment">//  c: ƒ ()</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;name: &quot;muyiy&quot;&#125;</span></span><br></pre></td></tr></table></figure></p><p>循环引用情况下，会报错<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: &#123;</span><br><span class="line">        c: <span class="number">2</span>,</span><br><span class="line">   d: <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.a = obj.b;</span><br><span class="line">obj.b.c = obj.a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="comment">// Uncaught TypeError: Converting circular structure to JSON</span></span><br></pre></td></tr></table></figure></p><p>new Date 情况下,转换错误<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="comment">// Mon Dec 24 2018 10:59:14 GMT+0800 (China Standard Time)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line"><span class="comment">// &quot;&quot;2018-12-24T02:59:25.776Z&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(<span class="keyword">new</span> <span class="built_in">Date</span>()));</span><br><span class="line"><span class="comment">// &quot;2018-12-24T02:59:41.523Z&quot;</span></span><br></pre></td></tr></table></figure></p><p>解决方法转成字符串或者时间戳就好。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> date = (<span class="keyword">new</span> <span class="built_in">Date</span>()).valueOf();</span><br><span class="line"><span class="comment">// 1545620645915</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(date);</span><br><span class="line"><span class="comment">// &quot;1545620673267&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(date));</span><br><span class="line"><span class="comment">// 1545620658688</span></span><br></pre></td></tr></table></figure></p><p>正则情况下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&quot;muyiy&quot;</span>,</span><br><span class="line">    a: <span class="regexp">/&#x27;123&#x27;/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="comment">// &#123;name: &quot;muyiy&quot;, a: /&#x27;123&#x27;/&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;name: &quot;muyiy&quot;, a: &#123;&#125;&#125;</span></span><br></pre></td></tr></table></figure></p><p>深拷贝也可以直接用lodash库。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;理解: 什么是赋值？&lt;br&gt;将一个数值或对象赋给某个变量的过程。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>IBM前端面经</title>
    <link href="https://nonentityboy.github.io/2019/09/30/ibm_Interview/"/>
    <id>https://nonentityboy.github.io/2019/09/30/ibm_Interview/</id>
    <published>2019-09-30T11:20:43.000Z</published>
    <updated>2020-06-20T17:00:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>9月，离职腾讯，回到学校。<br>在牛客刷到IBM的实习生招聘，于是就面试了一下，运气不错恰好过了。下面是我本次面试的面经。</p><span id="more"></span><h3 id="IBM-GBS-面经"><a href="#IBM-GBS-面经" class="headerlink" title="IBM GBS 面经"></a>IBM GBS 面经</h3><h4 id="一面（二十五-min-电面-）"><a href="#一面（二十五-min-电面-）" class="headerlink" title="一面（二十五 min 电面 ）"></a>一面（二十五 min 电面 ）</h4><p>Q：腾讯实习做了什么<br>A：Vue+Element UI 手机QQ质量平台管理系统<br>Q：假如能实习 实习时间？<br>A: 随时能入职 可实习一年以上 争取在公司转正<br>HTML 行内元素与块元素<br>CSS 垂直居中如何实现<br>介绍一下 AJAX 步骤呢<br>Vue 生命周期 ? keep-alive?<br>组件传值<br>实习时候Vuex 如何使用？有代码规范吗？<br>A：这个平台是我和导师写…balabala<br>面试官：好，今天面试就到这里了，今天你一面过了，然后明天需要 coding，需要考察一下<br>你的代码能力，对了你英语咋样？<br>A：balabala。</p><h4 id="二面-（-1h-17min-电面-collabedit-平台撸题）"><a href="#二面-（-1h-17min-电面-collabedit-平台撸题）" class="headerlink" title="二面 （ 1h 17min 电面+ collabedit 平台撸题）"></a>二面 （ 1h 17min 电面+ collabedit 平台撸题）</h4><p>——————<br>个人项目相关聊了四十分钟<br>——————</p><ol><li><p>js 实现两个数组一一对应<br>var arrA = [“语文”, “数学”, “英语”]<br>var arrB = [12,25,29]<br>让他变成 语文：12 数学：25 英语：29 的 json 形式</p></li><li><p>找到给定字符串（由小写字符组成）中的最长子串 T ，要求 T 中的每一字符出现次数都<br>不少于 k 。输出 T 的长度。 也就是 K 个重复字符的最长子串 leetcode 395 题<br>(这个题我太菜了没写出来，给面试官沟通了一下写成了下面的形式：<br>求了一个字符串 每个字符出现的次数</p></li><li><p>链表中环的入口节点 2x = n + x 用了这个思想<br>面试官：今天的面试就到这里了，后面等通知 （ ps:听到这个以为自己凉了 2333</p></li></ol><h4 id="三面-（-49-min-电面）"><a href="#三面-（-49-min-电面）" class="headerlink" title="三面 （ 49 min 电面）"></a>三面 （ 49 min 电面）</h4><p>面试官：我对你上次的代码进行了一次review，要不你再说一下这个题的思想：<br>至少有K个重复字符的最长子串？<br>微信小程序底层原理？（简历上有写）<br>MpVue 和 wepy 有啥异同<br>Vue 源码读过没有<br>Mock server<br>https 连接过程<br>UDP 为什么实时性比较强<br>为什么 UDP 有时比 TCP 更有优势（不知道 233333<br>http server 的字段<br>你再上一下 collabedit 平台，再写个题<br>数组中有一个数字出现的次数超过了数组长度的一半，找出这个数<br>面试官：其实我主要做后端，我再考你一些智力题<br>在一个圆桌上放硬币，2 个人比赛看谁最先放不下 （硬币的规格都是一样，..为了保证先放<br>的人赢，如何保证先放的人赢<br>A、B 两个人抓 100 个球，A 先 B 后，一次轮流抓取，每次允许抓球 1、2、4，抓到最后一个球为输，为了保证 A 抓球肯定赢，那 A 第一次需要抓几个<br>面试官介绍了一下部门的业务，我要是入职，需要做 angular4+express 相关<br>面试官：你对自己以后是如何规划的？<br>A:我想以后进入一个做前端工具的团队，或者 node 偏后端一点<br>面试官：考研吗？<br>A:不考研。<br>面试官：什么你不考研？？那我觉得你的规划路线有问题啊<br>A:…因为我觉得做前端工程方面，自己在企业中得到的进步会更大一些，然后自己热爱前端<br>巴拉巴拉<br>面试官：不不不，你还是得考研。</p><p>面完之后，过了两天一面面试官加微信说面试过了，正在走流程录取，让自己要是入职相关<br>随时有问题联系他。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;9月，离职腾讯，回到学校。&lt;br&gt;在牛客刷到IBM的实习生招聘，于是就面试了一下，运气不错恰好过了。下面是我本次面试的面经。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript中的继承方式</title>
    <link href="https://nonentityboy.github.io/2018/11/15/JS_inherit/"/>
    <id>https://nonentityboy.github.io/2018/11/15/JS_inherit/</id>
    <published>2018-11-15T03:20:43.000Z</published>
    <updated>2019-12-05T12:19:42.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>继承是OOP的核心内容之一。JavaScript中常见继承方式为：类式继承、构造函数式继承、组合式继承、原型式继承、寄生式继承、寄生组合式继承。</p><span id="more"></span><h3 id="类式继承"><a href="#类式继承" class="headerlink" title="类式继承"></a>类式继承</h3><p>类式继承，通过子类的原型prototype对父类的实例化实现。由于子类通过其原型prototype对父类实例化继承了父类，所以父类中的共有属性要是引用类型就会在子类中被所有实例共用。由于子类实现的继承是靠其原型prototype对父类的实例化实现的，因此在创建父类时是无法向父类传递参数的，因而在实例化父类时无法对父类构造函数内的属性进行初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;声明父类</span><br><span class="line">function SuperClass() &#123;</span><br><span class="line">  this.superValue &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;为父类添加共有方法</span><br><span class="line">SuperClass.prototype.getsuperValue &#x3D; function() &#123;</span><br><span class="line">  return this.superValue;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;声明子类</span><br><span class="line">function SubClass() &#123;</span><br><span class="line">  this.subValue &#x3D; false;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;继承父类（</span><br><span class="line">SubClass.prototype &#x3D; new SuperClass();</span><br><span class="line">&#x2F;&#x2F;为子类添加共有方法</span><br><span class="line">SubClass.prototype.getsubValue &#x3D; function () &#123;</span><br><span class="line">  return this.subValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数式继承"><a href="#构造函数式继承" class="headerlink" title="构造函数式继承"></a>构造函数式继承</h3><p>构造函数继承，通过在子类的构造函数作用环境中执行一次父类的构造函数来实现；由于没用涉及prototype，所以父类的原型方法不会被子类继承。要想被子类继承，就得把属性和函数放到父类的构造函数中，并且创建出来的（子类的）实例都会单独拥有一份，违背了 “代码复用”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;声明父类</span><br><span class="line">function SuperClass(id) &#123;</span><br><span class="line">  &#x2F;&#x2F;引用类型共有属性</span><br><span class="line">  this.books &#x3D; [&#39;JavaScript&#39;, &#39;html&#39;, &#39;css&#39;];</span><br><span class="line">  &#x2F;&#x2F;值类型共有属性</span><br><span class="line">  this.id &#x3D; id;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;父类声明原型方法</span><br><span class="line">SuperClass.prototype.showBooks &#x3D; function() &#123;</span><br><span class="line">  console.log(this.books);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;声明子类</span><br><span class="line">function SubClass(id) &#123;</span><br><span class="line">  &#x2F;&#x2F;继承父类</span><br><span class="line">  SuperClass.call(this, id); &#x2F;&#x2F;将子类的变量在父类中都执行一遍，父类中是给this绑定属性的，所以通过call就使得子类继承了父类的共有属性。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承，将类式继承和构造函数式继承综合，构造函数继承时执行了一遍父类的构造函数，在实现子类原型的类式继承又调用一遍父类构造函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function SuperClass(name) &#123;</span><br><span class="line">  this.name &#x3D; name;</span><br><span class="line">  this.books &#x3D; [&quot;javascript&quot;, &quot;html&quot;, &quot;css&quot;];</span><br><span class="line">&#125;</span><br><span class="line">SuperClass.prototype.getName &#x3D; function () &#123;</span><br><span class="line">  return this.name;</span><br><span class="line">&#125;</span><br><span class="line">function SubClass(name, time) &#123;</span><br><span class="line">  &#x2F;&#x2F;构造函数式基础父类name属性</span><br><span class="line">  SuperClass.call(this, name);</span><br><span class="line">  &#x2F;&#x2F;子类新增共有属性</span><br><span class="line">  this.time &#x3D; time;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;类式继承 子类原型继承父类</span><br><span class="line">SubClass.prototype &#x3D; new SuperClass();</span><br><span class="line">&#x2F;&#x2F;子类原型方法</span><br><span class="line">SubClass.prototype.getTime &#x3D; function () &#123;</span><br><span class="line">  return this.time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>原型式继承，借助原型prototype可以根据已有的对象创建一个新的对象，同时不必创建新的自定义对象类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;对类式继承的封装</span><br><span class="line">function inheritObejct(o) &#123; </span><br><span class="line">  &#x2F;&#x2F;声明一个过渡函数对象</span><br><span class="line">  function F() &#123;&#125;</span><br><span class="line">  &#x2F;&#x2F;过渡对象的原型继承父对象</span><br><span class="line">  F.prototype &#x3D; o;</span><br><span class="line">  &#x2F;&#x2F;返回过渡对象的一个实例， 该对象的原型继承了父对象</span><br><span class="line">  return new F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>基于这种在对象之间直接构建继承关系的理念，DC大神给出了上述的函数，这个inheritObject函数后来被ES5采纳，更名为Object.create()。</p><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>寄生式继承,对原型继承的第二次封装，并且在此过程中对继承的对象进行了拓展。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;声明基对象</span><br><span class="line">let book &#x3D; &#123;</span><br><span class="line">  name: &#39;js book&#39;,</span><br><span class="line">  alikeBook: [&quot;css book&quot;, &quot;html book&quot;,&quot;html book&quot;]</span><br><span class="line">&#125;;</span><br><span class="line">function createBook(obj) &#123;</span><br><span class="line">  &#x2F;&#x2F;通过原型继承方式创建新对象</span><br><span class="line">  let o &#x3D; new inheritObejct(obj);</span><br><span class="line">  &#x2F;&#x2F;拓展新对象</span><br><span class="line">  o.getName &#x3D; function() &#123;</span><br><span class="line">    return name;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;返回拓展后的新对象</span><br><span class="line">  return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>这里的寄生继承处理的是类的原型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function inhreitPrototype(SubClass, SuperClass) &#123;</span><br><span class="line">  &#x2F;&#x2F;复制一份父类的原型副本保存在变量中</span><br><span class="line">  let p &#x3D; inheritObejct(SuperClass.prototype);</span><br><span class="line">  &#x2F;&#x2F;修正因为重写子类原型导致子类的constructor属性被修改</span><br><span class="line">  p.constructor &#x3D; SubClass;</span><br><span class="line">  &#x2F;&#x2F;设置子类的原型</span><br><span class="line">  SubClass.prototype &#x3D; p;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;实例</span><br><span class="line">&#x2F;&#x2F;定义父类</span><br><span class="line">function SuperClass(name) &#123;</span><br><span class="line">  this.name &#x3D; name;</span><br><span class="line">  this.colors &#x3D; [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;定义父类的原型方法</span><br><span class="line">SuperClass.prototype.getName &#x3D; function() &#123;</span><br><span class="line">  return this.name;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;定义子类</span><br><span class="line">function SubClass(name, time) &#123;</span><br><span class="line">  &#x2F;&#x2F;构造函数式继承</span><br><span class="line">  SuperClass.call(this,name);</span><br><span class="line">  &#x2F;&#x2F;子类新增属性</span><br><span class="line">  this.time &#x3D; time;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*寄生式继承父类原型*&#x2F;</span><br><span class="line">inhreitPrototype(SubClass, SuperClass);</span><br><span class="line">&#x2F;*子类新增原型方法*&#x2F;</span><br><span class="line">SubClass.prototype.getTime &#x3D; function () &#123;</span><br><span class="line">  return this.time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="extend与deepCopy"><a href="#extend与deepCopy" class="headerlink" title="extend与deepCopy"></a>extend与deepCopy</h3><p>在JavaScript中继承是依赖于原型prototype链实现的，只有一条原型链，理论上不能继承多个父类。但是由于JavaScript是一门很灵活的语言，所以我们可是自己动手实现一个继承多对象属性的函数。</p><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>定义:JavaScript中每个函数都有一个指向某一对象的prototype属性，该函数被new操作符调用时会创建并返回一个对象，返回的对象中有一个指向其原型对象的proto属性，引擎在背后通过运用proto可以使得新建的对象可以调用相关原型的对象的方法和属性。原型对象本身也是对象，所以本身也包含了指向其原型的proto,由此就形成了一条链，称之为原型链。</p><p>作用:<br><img src="https://s1.ax1x.com/2018/02/07/91MwdK.jpg" alt="xxx"><br>如图，有了原型链，如果某个属性在对象B中而不在对象A中，我们依然可以把这个属性当作A的属性来访问。这就是继承的作用，它可以使得每个对象都能访问其继承链上的任何属性。</p><p>继承单对象属性的extend方法（针对值类型的属性）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function extend(child, parent) &#123;</span><br><span class="line">  for (let prop in parent) &#123;</span><br><span class="line">    child[prop] &#x3D; parent[prop];</span><br><span class="line">  &#125;</span><br><span class="line">  return child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承多对象的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function mix() &#123;</span><br><span class="line">  let i &#x3D; 1,</span><br><span class="line">      len &#x3D; arguments.length,</span><br><span class="line">      child &#x3D; arguments[0],</span><br><span class="line">      arg;</span><br><span class="line">  for(; i &lt; len; i++) &#123;</span><br><span class="line">    arg &#x3D; arguments[i];</span><br><span class="line">    for( let prop in arg) &#123;</span><br><span class="line">      child[prop] &#x3D; arg[prop];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>在JavaScript中复制一个对象的属性时，如果对象的属性为值类型则只需要简单的赋值语句即可，如果属性为引用类型，则需要依次复制该属性的属性，这里采用递归的思想解决这个问题。（如果不使用递归，则通过JSON解析解决）</p><p>为什么要这么做？当创建一个对象时，这个对象就被存储在内存中的某个物理位置，相关的变量和属性就会指向这些位置。</p><p><img src="https://s1.ax1x.com/2018/02/07/91lUUK.jpg" alt="x23"></p><blockquote><p>创建一个新对象，并让变量A指向该对象。<br>创建一个新变量B，并设置其与A相等，此时B和A指向了同一个对象，也就是内存中的同一个地址。<br>修改变量B所指的对象的color属性，将它设置为”white”,此时A.color 的值也为”white”。<br>再创建一个对象，然后让变量B指向这个新对象，A和B此时指向了内存中不同的位置，A、B从此再无关联</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://s1.ax1x.com/2018/02/07/918qat.jpg" alt="c1"><br><img src="https://s1.ax1x.com/2018/02/07/918XPf.jpg" alt="cc"><br><img src="https://s1.ax1x.com/2018/02/07/918bVI.jpg" alt="c3"><br><img src="https://s1.ax1x.com/2018/02/07/918LIP.jpg" alt="c4"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;继承是OOP的核心内容之一。JavaScript中常见继承方式为：类式继承、构造函数式继承、组合式继承、原型式继承、寄生式继承、寄生组合式继承。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Chrome浏览器拾遗</title>
    <link href="https://nonentityboy.github.io/2018/06/28/chrome_Browser/"/>
    <id>https://nonentityboy.github.io/2018/06/28/chrome_Browser/</id>
    <published>2018-06-28T01:20:43.000Z</published>
    <updated>2020-06-20T16:58:40.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>总括： Chrome浏览器我想是每一个前端er必用工具之一吧，一部分原因是它速度快，体积不大，支持的新特性也比其它浏览器多，还有一部分我想就是因为它的控制台功能强大了吧，说它是神器一点也不过分，很方便。但其实很多开发者并没有用出控制台的精髓，只是使用简单的console.log();其实控制台功能远远不止这么简单哦。<br><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=1919447253,1610821380&amp;fm=26&amp;gp=0.jpg" alt="chrome"><br><span id="more"></span></p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>console.clear</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.clear();清空控制台，这个应该和console.log知名度一样高吧。</span><br></pre></td></tr></table></figure><p>console.log家族<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先简单介绍一下chrome的控制台，打开chrome浏览器，按f12就可以轻松的打开控制台</span><br></pre></td></tr></table></figure></p><p>如果你是一位开发者，我想console.log肯定是经常使用的了，我们主要看看console.log的几个兄弟：<br><img src="http://img.blog.csdn.net/20160909211537532" alt="信息"></p><p>大家都会用log，但很少有人能够很好地利用console.error , console.warn 等将输出到控制台的信息进行分类整理。他们功能区别不大，意义在于将输出到控制台的信息进行归类，或者说让它们更语义化。</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.group(&quot;app.bundle&quot;);</span><br><span class="line">console.warn(&quot;来自bundle模块的警告信息1&quot;);console.warn(&quot;来自bundle模块的警告信息2&quot;);</span><br><span class="line">console.groupEnd();</span><br><span class="line">console.group(&quot;app.bundle&quot;);</span><br><span class="line">console.log(&quot;来自bundle模块的信息1&quot;);console.log(&quot;来自bundle模块的信息2&quot;);</span><br><span class="line">console.groupEnd();</span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20160909212018524" alt="xinxi"></p><p>这样的控制台信息看上去就一目了然了，就不用再为了找这是属于那一行代码输出的再翻一遍源码了。</p><p>另外，console.log家族还给我们提供了一个的API：第一个参数可以带一些格式化指令，比如%c,\n;看下面这个炫酷的效果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#39;%chello world&#39;, &#39;background-image:-webkit-gradient( linear, left top, right top, color-stop(0, #f22), color-stop(0.15, #f2f), color-stop(0.3, #22f), color-stop(0.45, #2ff), color-stop(0.6, #2f2),color-stop(0.75, #2f2), color-stop(0.9, #ff2), color-stop(1, #f22) );color:transparent;-webkit-background-clip: text;font-size:5em;&#39;);</span><br></pre></td></tr></table></figure><br><img src="http://img.blog.csdn.net/20160909213512650" alt="xx7"></p><p>当然，图片也是可以的，读者可以自行尝试，修改上述代码即可。<br>console.log() 接收不定参数，参数间用逗号分隔，最终会输出会将它们以空白字符连接。</p><p><img src="http://img.blog.csdn.net/20160909215338908" alt="xx8aaaa"></p><p>console.table</p><blockquote><p>看着这种“黑魔法”是不是有种坑分的感觉呢，其实还不止哦！console.table可以让我们输出表格,示例：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var data &#x3D; &#123;code:200,content:[&#123;&#39;品名&#39;: &#39;杜雷斯&#39;, &#39;数量&#39;: 4&#125;, &#123;&#39;品名&#39;: &#39;冈本&#39;, &#39;数量&#39;: 3&#125;]&#125;;</span><br><span class="line">console.table(data.content);</span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20160909214911953" alt="xx9"><br>有的时候后端传回来一大串数据，是不是觉得直接console.log或是通过抓包工具查看都会让人晕头转向呢，这个时候正事console.table发挥作用的时候了，以表格的形式呈现数据，自然一目了然。</p><p>console.assert<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var isDebug&#x3D;false;</span><br><span class="line">console.assert(isDebug,&#39;开发中的log信息。。。&#39;);</span><br></pre></td></tr></table></figure></p><blockquote><p>当你想代码满足某些条件时才输出信息到控制台，那么你大可不必写if或者三元表达式来达到目的，cosole.assert便是这样场景下一种很好的工具，它会先对传入的表达式进行断言，只有表达式为假时才输出相应信息到控制台。 <img src="http://img.blog.csdn.net/20160909215637362" alt="xx0"></p></blockquote><p>console.count</p><blockquote><p>除了条件输出的场景，还有常见的场景是计数。<br>当你想统计某段代码执行了多少次时也大可不必自己去写相关逻辑，内置的console.count可以很地胜任这样的任务.<br><img src="http://img.blog.csdn.net/20160909215931738" alt="xx1"></p></blockquote><p>console.dir</p><blockquote><p>将DOM结点以JavaScript对象的形式输出到控制台<br>而console.log是直接将该DOM结点以DOM树的结构进行输出，与在元素审查时看到的结构是一致的。不同的展现形式，同样的优雅，各种体位任君选择反正就是方便与体贴。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.dir(document.body);</span><br><span class="line">console.log(document.body);</span><br></pre></td></tr></table></figure><br><img src="http://img.blog.csdn.net/20160909220149156" alt="xx2"></p></blockquote><p>console.time &amp; console.timeEnd</p><blockquote><p>输出一些调试信息是控制台最常用的功能，当然，它的功能远不止于此。当做一些性能测试时，同样可以在这里很方便地进行。比如需要考量一段代码执行的耗时情况时，可以用console.time与 console.timeEnd来做此事。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.time(&quot;Array耗时&quot;);</span><br><span class="line">var array&#x3D; new Array(10000000);</span><br><span class="line">for (var i &#x3D; array.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">    array[i] &#x3D; new Object();</span><br><span class="line">&#125;;</span><br><span class="line">console.timeEnd(&quot;Array耗时&quot;);</span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20160909220932148" alt="xx3"></p><blockquote><p>当想要查看CPU使用相关的信息时，可以使用console.profile配合 console.profileEnd来完成这个需求。<br>这一功能可以通过UI界面来完成，Chrome 开发者工具里面有个tab便是Profile。使用方法和console.time基本一样，其实time开发者工具里也有个tab就是timeline。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;总括： Chrome浏览器我想是每一个前端er必用工具之一吧，一部分原因是它速度快，体积不大，支持的新特性也比其它浏览器多，还有一部分我想就是因为它的控制台功能强大了吧，说它是神器一点也不过分，很方便。但其实很多开发者并没有用出控制台的精髓，只是使用简单的console.log();其实控制台功能远远不止这么简单哦。&lt;br&gt;&lt;img src=&quot;https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=1919447253,1610821380&amp;amp;fm=26&amp;amp;gp=0.jpg&quot; alt=&quot;chrome&quot;&gt;&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>【数组去重】写一个数组去重的方法</title>
    <link href="https://nonentityboy.github.io/2018/02/10/Array_deduplication/"/>
    <id>https://nonentityboy.github.io/2018/02/10/Array_deduplication/</id>
    <published>2018-02-10T03:20:43.000Z</published>
    <updated>2020-06-20T16:55:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>开发过程中，我们总会遇到一个数组中有多个数字/字符的情况，如果需要去重的话。我们有以下方法。</p><span id="more"></span><h3 id="一、利用ES6的Set数据结构"><a href="#一、利用ES6的Set数据结构" class="headerlink" title="一、利用ES6的Set数据结构"></a>一、利用ES6的Set数据结构</h3><p>原理：Set数据结构，它类似于数组，其成员的值都是唯一的。<br>作用：将数组去重后，变成object类型。</p><p>1.利用拓展运算符(…)内部使用for…of循环<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> unique = [...new <span class="built_in">Set</span>(arr)];  <span class="comment">//[3,5,2]</span></span><br></pre></td></tr></table></figure></p><p>2.利用Array.from将Set结构转换成数组<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupe</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));</span><br><span class="line">&#125;</span><br><span class="line">dedupe([<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])  <span class="comment">// [1,2,3]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="二、利用indexOf与for循环"><a href="#二、利用indexOf与for循环" class="headerlink" title="二、利用indexOf与for循环"></a>二、利用indexOf与for循环</h3><p>原理：查找非重复的值push进新的数组<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">distinct</span>(<span class="params">arr</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">let</span> newArr = []; </span><br><span class="line">    <span class="keyword">let</span> arrlength = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;=length;i++)&#123; </span><br><span class="line">        <span class="keyword">if</span>(newArr.indexOf(arr[i])== -<span class="number">1</span>)&#123;</span><br><span class="line">            newArr.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(distinct(arr))</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;开发过程中，我们总会遇到一个数组中有多个数字/字符的情况，如果需要去重的话。我们有以下方法。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Hexo启动</title>
    <link href="https://nonentityboy.github.io/2018/02/03/hello-world/"/>
    <id>https://nonentityboy.github.io/2018/02/03/hello-world/</id>
    <published>2018-02-03T03:20:43.000Z</published>
    <updated>2019-12-05T12:33:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post（创建一个新的博客）"><a href="#Create-a-new-post（创建一个新的博客）" class="headerlink" title="Create a new post（创建一个新的博客）"></a>Create a new post（创建一个新的博客）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server-（启动hexo服务）"><a href="#Run-server-（启动hexo服务）" class="headerlink" title="Run server （启动hexo服务）"></a>Run server （启动hexo服务）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files-（生成静态文件）"><a href="#Generate-static-files-（生成静态文件）" class="headerlink" title="Generate static files （生成静态文件）"></a>Generate static files （生成静态文件）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites（部署到远程站点）"><a href="#Deploy-to-remote-sites（部署到远程站点）" class="headerlink" title="Deploy to remote sites（部署到远程站点）"></a>Deploy to remote sites（部署到远程站点）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
